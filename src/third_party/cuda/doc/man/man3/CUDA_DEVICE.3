.TH "Device Management" 3 "12 Jan 2017" "Version 6.0" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Device Management \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGet\fP (\fBCUdevice\fP *device, int ordinal)"
.br
.RI "\fIReturns a handle to a compute device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetAttribute\fP (int *pi, \fBCUdevice_attribute\fP attrib, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns information about the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetCount\fP (int *count)"
.br
.RI "\fIReturns the number of compute-capable devices. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetName\fP (char *name, int len, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns an identifer string for the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceTotalMem\fP (size_t *bytes, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns the total amount of memory on the device. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\\brief device management functions of the low-level CUDA driver API (\fBcuda.h\fP)
.PP
This section describes the device management functions of the low-level CUDA driver application programming interface. 
.SH "Function Documentation"
.PP 
.SS "\fBCUresult\fP cuDeviceGet (\fBCUdevice\fP * device, int ordinal)"
.PP
Returns in \fC*device\fP a device handle given an ordinal in the range \fB[0, \fBcuDeviceGetCount()\fP-1]\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP - Returned device handle 
.br
\fIordinal\fP - Device number to get handle for
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDeviceGetAttribute\fP, \fBcuDeviceGetCount\fP, \fBcuDeviceGetName\fP, \fBcuDeviceTotalMem\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDeviceGetAttribute (int * pi, \fBCUdevice_attribute\fP attrib, \fBCUdevice\fP dev)"
.PP
Returns in \fC*pi\fP the integer value of the attribute \fCattrib\fP on device \fCdev\fP. The supported attributes are:
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK\fP: Maximum number of threads per block;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X\fP: Maximum x-dimension of a block;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y\fP: Maximum y-dimension of a block;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z\fP: Maximum z-dimension of a block;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X\fP: Maximum x-dimension of a grid;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y\fP: Maximum y-dimension of a grid;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z\fP: Maximum z-dimension of a grid;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK\fP: Maximum amount of shared memory available to a thread block in bytes;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY\fP: Memory available on device for __constant__ variables in a CUDA C kernel in bytes;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_WARP_SIZE\fP: Warp size in threads;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_PITCH\fP: Maximum pitch in bytes allowed by the memory copy functions that involve memory regions allocated through \fBcuMemAllocPitch()\fP;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH\fP: Maximum 1D texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH\fP: Maximum width for a 1D texture bound to linear memory;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH\fP: Maximum mipmapped 1D texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH\fP: Maximum 2D texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT\fP: Maximum 2D texture height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH\fP: Maximum width for a 2D texture bound to linear memory;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT\fP: Maximum height for a 2D texture bound to linear memory;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH\fP: Maximum pitch in bytes for a 2D texture bound to linear memory;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH\fP: Maximum mipmapped 2D texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT\fP: Maximum mipmapped 2D texture height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH\fP: Maximum 3D texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT\fP: Maximum 3D texture height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH\fP: Maximum 3D texture depth;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE\fP: Alternate maximum 3D texture width, 0 if no alternate maximum 3D texture size is supported;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE\fP: Alternate maximum 3D texture height, 0 if no alternate maximum 3D texture size is supported;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE\fP: Alternate maximum 3D texture depth, 0 if no alternate maximum 3D texture size is supported;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH\fP: Maximum cubemap texture width or height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH\fP: Maximum 1D layered texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS\fP: Maximum layers in a 1D layered texture;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH\fP: Maximum 2D layered texture width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT\fP: Maximum 2D layered texture height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS\fP: Maximum layers in a 2D layered texture;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH\fP: Maximum cubemap layered texture width or height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS\fP: Maximum layers in a cubemap layered texture;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH\fP: Maximum 1D surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH\fP: Maximum 2D surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT\fP: Maximum 2D surface height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH\fP: Maximum 3D surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT\fP: Maximum 3D surface height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH\fP: Maximum 3D surface depth;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH\fP: Maximum 1D layered surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS\fP: Maximum layers in a 1D layered surface;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH\fP: Maximum 2D layered surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT\fP: Maximum 2D layered surface height;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS\fP: Maximum layers in a 2D layered surface;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH\fP: Maximum cubemap surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH\fP: Maximum cubemap layered surface width;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS\fP: Maximum layers in a cubemap layered surface;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK\fP: Maximum number of 32-bit registers available to a thread block;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_CLOCK_RATE\fP: The typical clock frequency in kilohertz;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT\fP: Alignment requirement; texture base addresses aligned to textureAlign bytes do not need an offset applied to texture fetches;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT\fP: Pitch alignment requirement for 2D texture references bound to pitched memory;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_GPU_OVERLAP\fP: 1 if the device can concurrently copy memory between host and device while executing a kernel, or 0 if not;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT\fP: Number of multiprocessors on the device;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT\fP: 1 if there is a run time limit for kernels executed on the device, or 0 if not;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_INTEGRATED\fP: 1 if the device is integrated with the memory subsystem, or 0 if not;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY\fP: 1 if the device can map host memory into the CUDA address space, or 0 if not;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_COMPUTE_MODE\fP: Compute mode that device is currently in. Available modes are as follows:
.IP "  \(bu" 4
\fBCU_COMPUTEMODE_DEFAULT\fP: Default mode - Device is not restricted and can have multiple CUDA contexts present at a single time.
.IP "  \(bu" 4
\fBCU_COMPUTEMODE_PROHIBITED\fP: Compute-prohibited mode - Device is prohibited from creating new CUDA contexts.
.IP "  \(bu" 4
\fBCU_COMPUTEMODE_EXCLUSIVE_PROCESS\fP: Compute-exclusive-process mode - Device can have only one context used by a single process at a time.
.PP

.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS\fP: 1 if the device supports executing multiple kernels within the same context simultaneously, or 0 if not. It is not guaranteed that multiple kernels will be resident on the device concurrently so this feature should not be relied upon for correctness;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_ECC_ENABLED\fP: 1 if error correction is enabled on the device, 0 if error correction is disabled or not supported by the device;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_PCI_BUS_ID\fP: PCI bus identifier of the device;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID\fP: PCI device (also known as slot) identifier of the device;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_TCC_DRIVER\fP: 1 if the device is using a TCC driver. TCC is only available on Tesla hardware running Windows Vista or later;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE\fP: Peak memory clock frequency in kilohertz;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH\fP: Global memory bus width in bits;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE\fP: Size of L2 cache in bytes. 0 if the device doesn't have L2 cache;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR\fP: Maximum resident threads per multiprocessor;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING\fP: 1 if the device shares a unified address space with the host, or 0 if not;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR\fP: Major compute capability version number;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR\fP: Minor compute capability version number;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED\fP: 1 if device supports caching globals in L1 cache, 0 if caching globals in L1 cache is not supported by the device;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED\fP: 1 if device supports caching locals in L1 cache, 0 if caching locals in L1 cache is not supported by the device;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR\fP: Maximum amount of shared memory available to a multiprocessor in bytes; this amount is shared by all thread blocks simultaneously resident on a multiprocessor;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR\fP: Maximum number of 32-bit registers available to a multiprocessor; this number is shared by all thread blocks simultaneously resident on a multiprocessor;
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MANAGED_MEMORY\fP: 1 if device supports allocating managed memory on this system, 0 if allocating managed memory is not supported by the device on this system.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD\fP: 1 if device is on a multi-GPU board, 0 if not.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID\fP: Unique identifier for a group of devices associated with the same board. Devices on the same multi-GPU board will share the same identifier.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED\fP: 1 if Link between the device and the host supports native atomic operations.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO\fP: Ratio of single precision performance (in floating-point operations per second) to double precision performance.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS\fP: Device suppports coherently accessing pageable memory without calling cudaHostRegister on it.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS\fP: Device can coherently access managed memory concurrently with the CPU.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED\fP: Device supports Compute Preemption.
.IP "\(bu" 2
\fBCU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM\fP: Device can access host registered memory at the same virtual address as the CPU.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIpi\fP - Returned device attribute value 
.br
\fIattrib\fP - Device attribute to query 
.br
\fIdev\fP - Device handle
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDeviceGetCount\fP, \fBcuDeviceGetName\fP, \fBcuDeviceGet\fP, \fBcuDeviceTotalMem\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDeviceGetCount (int * count)"
.PP
Returns in \fC*count\fP the number of devices with compute capability greater than or equal to 1.0 that are available for execution. If there is no such device, \fBcuDeviceGetCount()\fP returns 0.
.PP
\fBParameters:\fP
.RS 4
\fIcount\fP - Returned number of compute-capable devices
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDeviceGetAttribute\fP, \fBcuDeviceGetName\fP, \fBcuDeviceGet\fP, \fBcuDeviceTotalMem\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDeviceGetName (char * name, int len, \fBCUdevice\fP dev)"
.PP
Returns an ASCII string identifying the device \fCdev\fP in the NULL-terminated string pointed to by \fCname\fP. \fClen\fP specifies the maximum length of the string that may be returned.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP - Returned identifier string for the device 
.br
\fIlen\fP - Maximum length of string to store in \fCname\fP 
.br
\fIdev\fP - Device to get identifier string for
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDeviceGetAttribute\fP, \fBcuDeviceGetCount\fP, \fBcuDeviceGet\fP, \fBcuDeviceTotalMem\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDeviceTotalMem (size_t * bytes, \fBCUdevice\fP dev)"
.PP
Returns in \fC*bytes\fP the total amount of memory available on the device \fCdev\fP in bytes.
.PP
\fBParameters:\fP
.RS 4
\fIbytes\fP - Returned memory available on device in bytes 
.br
\fIdev\fP - Device handle
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDeviceGetAttribute\fP, \fBcuDeviceGetCount\fP, \fBcuDeviceGetName\fP, \fBcuDeviceGet\fP, 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code.
