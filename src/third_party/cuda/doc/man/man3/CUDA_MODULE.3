.TH "Module Management" 3 "12 Jan 2017" "Version 6.0" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Module Management \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkAddData\fP (CUlinkState state, \fBCUjitInputType\fP type, void *data, size_t size, const char *name, unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues)"
.br
.RI "\fIAdd an input to a pending linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkAddFile\fP (CUlinkState state, \fBCUjitInputType\fP type, const char *path, unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues)"
.br
.RI "\fIAdd a file input to a pending linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkComplete\fP (CUlinkState state, void **cubinOut, size_t *sizeOut)"
.br
.RI "\fIComplete a pending linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkCreate\fP (unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues, CUlinkState *stateOut)"
.br
.RI "\fICreates a pending JIT linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkDestroy\fP (CUlinkState state)"
.br
.RI "\fIDestroys state for a JIT linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetFunction\fP (\fBCUfunction\fP *hfunc, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a function handle. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetGlobal\fP (\fBCUdeviceptr\fP *dptr, size_t *bytes, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a global pointer from a module. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetSurfRef\fP (\fBCUsurfref\fP *pSurfRef, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a handle to a surface reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetTexRef\fP (\fBCUtexref\fP *pTexRef, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a handle to a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoad\fP (\fBCUmodule\fP *module, const char *fname)"
.br
.RI "\fILoads a compute module. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoadData\fP (\fBCUmodule\fP *module, const void *image)"
.br
.RI "\fILoad a module's data. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoadDataEx\fP (\fBCUmodule\fP *module, const void *image, unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues)"
.br
.RI "\fILoad a module's data with options. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoadFatBinary\fP (\fBCUmodule\fP *module, const void *fatCubin)"
.br
.RI "\fILoad a module's data. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleUnload\fP (\fBCUmodule\fP hmod)"
.br
.RI "\fIUnloads a module. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\\brief module management functions of the low-level CUDA driver API (\fBcuda.h\fP)
.PP
This section describes the module management functions of the low-level CUDA driver application programming interface. 
.SH "Function Documentation"
.PP 
.SS "\fBCUresult\fP cuLinkAddData (CUlinkState state, \fBCUjitInputType\fP type, void * data, size_t size, const char * name, unsigned int numOptions, \fBCUjit_option\fP * options, void ** optionValues)"
.PP
Ownership of \fCdata\fP is retained by the caller. No reference is retained to any inputs after this call returns.
.PP
This method accepts only compiler options, which are used if the data must be compiled from PTX, and does not accept any of \fBCU_JIT_WALL_TIME\fP, \fBCU_JIT_INFO_LOG_BUFFER\fP, \fBCU_JIT_ERROR_LOG_BUFFER\fP, \fBCU_JIT_TARGET_FROM_CUCONTEXT\fP, or \fBCU_JIT_TARGET\fP.
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP A pending linker action. 
.br
\fItype\fP The type of the input data. 
.br
\fIdata\fP The input data. PTX must be NULL-terminated. 
.br
\fIsize\fP The length of the input data. 
.br
\fIname\fP An optional name for this input in log messages. 
.br
\fInumOptions\fP Size of options. 
.br
\fIoptions\fP Options to be applied only for this input (overrides options from \fBcuLinkCreate\fP). 
.br
\fIoptionValues\fP Array of option values, each cast to void *.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_INVALID_HANDLE\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_IMAGE\fP, \fBCUDA_ERROR_INVALID_PTX\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuLinkCreate\fP, \fBcuLinkAddFile\fP, \fBcuLinkComplete\fP, \fBcuLinkDestroy\fP 
.RE
.PP

.SS "\fBCUresult\fP cuLinkAddFile (CUlinkState state, \fBCUjitInputType\fP type, const char * path, unsigned int numOptions, \fBCUjit_option\fP * options, void ** optionValues)"
.PP
No reference is retained to any inputs after this call returns.
.PP
This method accepts only compiler options, which are used if the input must be compiled from PTX, and does not accept any of \fBCU_JIT_WALL_TIME\fP, \fBCU_JIT_INFO_LOG_BUFFER\fP, \fBCU_JIT_ERROR_LOG_BUFFER\fP, \fBCU_JIT_TARGET_FROM_CUCONTEXT\fP, or \fBCU_JIT_TARGET\fP.
.PP
This method is equivalent to invoking \fBcuLinkAddData\fP on the contents of the file.
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP A pending linker action 
.br
\fItype\fP The type of the input data 
.br
\fIpath\fP Path to the input file 
.br
\fInumOptions\fP Size of options 
.br
\fIoptions\fP Options to be applied only for this input (overrides options from \fBcuLinkCreate\fP) 
.br
\fIoptionValues\fP Array of option values, each cast to void *
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_FILE_NOT_FOUND\fP \fBCUDA_ERROR_INVALID_HANDLE\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_IMAGE\fP, \fBCUDA_ERROR_INVALID_PTX\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuLinkCreate\fP, \fBcuLinkAddData\fP, \fBcuLinkComplete\fP, \fBcuLinkDestroy\fP 
.RE
.PP

.SS "\fBCUresult\fP cuLinkComplete (CUlinkState state, void ** cubinOut, size_t * sizeOut)"
.PP
Completes the pending linker action and returns the cubin image for the linked device code, which can be used with \fBcuModuleLoadData\fP. The cubin is owned by \fCstate\fP, so it should be loaded before \fCstate\fP is destroyed via \fBcuLinkDestroy\fP. This call does not destroy \fCstate\fP.
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP A pending linker invocation 
.br
\fIcubinOut\fP On success, this will point to the output image 
.br
\fIsizeOut\fP Optional parameter to receive the size of the generated image
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_INVALID_HANDLE\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuLinkCreate\fP, \fBcuLinkAddData\fP, \fBcuLinkAddFile\fP, \fBcuLinkDestroy\fP, \fBcuModuleLoadData\fP 
.RE
.PP

.SS "\fBCUresult\fP cuLinkCreate (unsigned int numOptions, \fBCUjit_option\fP * options, void ** optionValues, CUlinkState * stateOut)"
.PP
If the call is successful, the caller owns the returned CUlinkState, which should eventually be destroyed with \fBcuLinkDestroy\fP. The device code machine size (32 or 64 bit) will match the calling application.
.PP
Both linker and compiler options may be specified. Compiler options will be applied to inputs to this linker action which must be compiled from PTX. The options \fBCU_JIT_WALL_TIME\fP, \fBCU_JIT_INFO_LOG_BUFFER_SIZE_BYTES\fP, and \fBCU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES\fP will accumulate data until the CUlinkState is destroyed.
.PP
\fCoptionValues\fP must remain valid for the life of the CUlinkState if output options are used. No other references to inputs are maintained after this call returns.
.PP
\fBParameters:\fP
.RS 4
\fInumOptions\fP Size of options arrays 
.br
\fIoptions\fP Array of linker and compiler options 
.br
\fIoptionValues\fP Array of option values, each cast to void * 
.br
\fIstateOut\fP On success, this will contain a CUlinkState to specify and complete this action
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuLinkAddData\fP, \fBcuLinkAddFile\fP, \fBcuLinkComplete\fP, \fBcuLinkDestroy\fP 
.RE
.PP

.SS "\fBCUresult\fP cuLinkDestroy (CUlinkState state)"
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP State object for the linker invocation
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_INVALID_HANDLE\fP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuLinkCreate\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleGetFunction (\fBCUfunction\fP * hfunc, \fBCUmodule\fP hmod, const char * name)"
.PP
Returns in \fC*hfunc\fP the handle of the function of name \fCname\fP located in module \fChmod\fP. If no function of that name exists, \fBcuModuleGetFunction()\fP returns \fBCUDA_ERROR_NOT_FOUND\fP.
.PP
\fBParameters:\fP
.RS 4
\fIhfunc\fP - Returned function handle 
.br
\fIhmod\fP - Module to retrieve function from 
.br
\fIname\fP - Name of function to retrieve
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_NOT_FOUND\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleGetGlobal (\fBCUdeviceptr\fP * dptr, size_t * bytes, \fBCUmodule\fP hmod, const char * name)"
.PP
Returns in \fC*dptr\fP and \fC*bytes\fP the base pointer and size of the global of name \fCname\fP located in module \fChmod\fP. If no variable of that name exists, \fBcuModuleGetGlobal()\fP returns \fBCUDA_ERROR_NOT_FOUND\fP. Both parameters \fCdptr\fP and \fCbytes\fP are optional. If one of them is NULL, it is ignored.
.PP
\fBParameters:\fP
.RS 4
\fIdptr\fP - Returned global device pointer 
.br
\fIbytes\fP - Returned global size in bytes 
.br
\fIhmod\fP - Module to retrieve global from 
.br
\fIname\fP - Name of global to retrieve
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_NOT_FOUND\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleGetSurfRef (\fBCUsurfref\fP * pSurfRef, \fBCUmodule\fP hmod, const char * name)"
.PP
Returns in \fC*pSurfRef\fP the handle of the surface reference of name \fCname\fP in the module \fChmod\fP. If no surface reference of that name exists, \fBcuModuleGetSurfRef()\fP returns \fBCUDA_ERROR_NOT_FOUND\fP.
.PP
\fBParameters:\fP
.RS 4
\fIpSurfRef\fP - Returned surface reference 
.br
\fIhmod\fP - Module to retrieve surface reference from 
.br
\fIname\fP - Name of surface reference to retrieve
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_NOT_FOUND\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleGetTexRef (\fBCUtexref\fP * pTexRef, \fBCUmodule\fP hmod, const char * name)"
.PP
Returns in \fC*pTexRef\fP the handle of the texture reference of name \fCname\fP in the module \fChmod\fP. If no texture reference of that name exists, \fBcuModuleGetTexRef()\fP returns \fBCUDA_ERROR_NOT_FOUND\fP. This texture reference handle should not be destroyed, since it will be destroyed when the module is unloaded.
.PP
\fBParameters:\fP
.RS 4
\fIpTexRef\fP - Returned texture reference 
.br
\fIhmod\fP - Module to retrieve texture reference from 
.br
\fIname\fP - Name of texture reference to retrieve
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_NOT_FOUND\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetSurfRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleLoad (\fBCUmodule\fP * module, const char * fname)"
.PP
Takes a filename \fCfname\fP and loads the corresponding module \fCmodule\fP into the current context. The CUDA driver API does not attempt to lazily allocate the resources needed by a module; if the memory for functions and data (constant and global) needed by the module cannot be allocated, \fBcuModuleLoad()\fP fails. The file should be a \fIcubin\fP file as output by \fBnvcc\fP, or a \fIPTX\fP file either as output by \fBnvcc\fP or handwritten, or a \fIfatbin\fP file as output by \fBnvcc\fP from toolchain 4.0 or later.
.PP
\fBParameters:\fP
.RS 4
\fImodule\fP - Returned module 
.br
\fIfname\fP - Filename of module to load
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_PTX\fP, \fBCUDA_ERROR_NOT_FOUND\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_FILE_NOT_FOUND\fP, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP, \fBCUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND\fP, \fBCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleLoadData (\fBCUmodule\fP * module, const void * image)"
.PP
Takes a pointer \fCimage\fP and loads the corresponding module \fCmodule\fP into the current context. The pointer may be obtained by mapping a \fIcubin\fP or \fIPTX\fP or \fIfatbin\fP file, passing a \fIcubin\fP or \fIPTX\fP or \fIfatbin\fP file as a NULL-terminated text string, or incorporating a \fIcubin\fP or \fIfatbin\fP object into the executable resources and using operating system calls such as Windows \fCFindResource()\fP to obtain the pointer.
.PP
\fBParameters:\fP
.RS 4
\fImodule\fP - Returned module 
.br
\fIimage\fP - Module data to load
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_PTX\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP, \fBCUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND\fP, \fBCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleLoadDataEx (\fBCUmodule\fP * module, const void * image, unsigned int numOptions, \fBCUjit_option\fP * options, void ** optionValues)"
.PP
Takes a pointer \fCimage\fP and loads the corresponding module \fCmodule\fP into the current context. The pointer may be obtained by mapping a \fIcubin\fP or \fIPTX\fP or \fIfatbin\fP file, passing a \fIcubin\fP or \fIPTX\fP or \fIfatbin\fP file as a NULL-terminated text string, or incorporating a \fIcubin\fP or \fIfatbin\fP object into the executable resources and using operating system calls such as Windows \fCFindResource()\fP to obtain the pointer. Options are passed as an array via \fCoptions\fP and any corresponding parameters are passed in \fCoptionValues\fP. The number of total options is supplied via \fCnumOptions\fP. Any outputs will be returned via \fCoptionValues\fP.
.PP
\fBParameters:\fP
.RS 4
\fImodule\fP - Returned module 
.br
\fIimage\fP - Module data to load 
.br
\fInumOptions\fP - Number of options 
.br
\fIoptions\fP - Options for JIT 
.br
\fIoptionValues\fP - Option values for JIT
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_PTX\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP, \fBCUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND\fP, \fBCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadFatBinary\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleLoadFatBinary (\fBCUmodule\fP * module, const void * fatCubin)"
.PP
Takes a pointer \fCfatCubin\fP and loads the corresponding module \fCmodule\fP into the current context. The pointer represents a \fIfat binary\fP object, which is a collection of different \fIcubin\fP and/or \fIPTX\fP files, all representing the same device code, but compiled and optimized for different architectures.
.PP
Prior to CUDA 4.0, there was no documented API for constructing and using fat binary objects by programmers. Starting with CUDA 4.0, fat binary objects can be constructed by providing the \fI-fatbin option\fP to \fBnvcc\fP. More information can be found in the \fBnvcc\fP document.
.PP
\fBParameters:\fP
.RS 4
\fImodule\fP - Returned module 
.br
\fIfatCubin\fP - Fat binary to load
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_INVALID_PTX\fP, \fBCUDA_ERROR_NOT_FOUND\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP, \fBCUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND\fP, \fBCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleUnload\fP 
.RE
.PP

.SS "\fBCUresult\fP cuModuleUnload (\fBCUmodule\fP hmod)"
.PP
Unloads a module \fChmod\fP from the current context.
.PP
\fBParameters:\fP
.RS 4
\fIhmod\fP - Module to unload
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_VALUE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuModuleGetFunction\fP, \fBcuModuleGetGlobal\fP, \fBcuModuleGetTexRef\fP, \fBcuModuleLoad\fP, \fBcuModuleLoadData\fP, \fBcuModuleLoadDataEx\fP, \fBcuModuleLoadFatBinary\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code.
