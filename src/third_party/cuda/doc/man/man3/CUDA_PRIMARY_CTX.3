.TH "Primary Context Management" 3 "12 Jan 2017" "Version 6.0" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Primary Context Management \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxGetState\fP (\fBCUdevice\fP dev, unsigned int *flags, int *active)"
.br
.RI "\fIGet the state of the primary context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxRelease\fP (\fBCUdevice\fP dev)"
.br
.RI "\fIRelease the primary context on the GPU. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxReset\fP (\fBCUdevice\fP dev)"
.br
.RI "\fIDestroy all allocations and reset all state on the primary context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxRetain\fP (\fBCUcontext\fP *pctx, \fBCUdevice\fP dev)"
.br
.RI "\fIRetain the primary context on the GPU. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxSetFlags\fP (\fBCUdevice\fP dev, unsigned int flags)"
.br
.RI "\fISet flags for the primary context. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\\brief primary context management functions of the low-level CUDA driver API (\fBcuda.h\fP)
.PP
This section describes the primary context management functions of the low-level CUDA driver application programming interface.
.PP
The primary context unique per device and it's shared with CUDA runtime API. Those functions allows seemless integration with other libraries using CUDA. 
.SH "Function Documentation"
.PP 
.SS "\fBCUresult\fP cuDevicePrimaryCtxGetState (\fBCUdevice\fP dev, unsigned int * flags, int * active)"
.PP
Returns in \fC*flags\fP the flags for the primary context of \fCdev\fP, and in \fC*active\fP whether it is active. See \fBcuDevicePrimaryCtxSetFlags\fP for flag values.
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP - Device to get primary context flags for 
.br
\fIflags\fP - Pointer to store flags 
.br
\fIactive\fP - Pointer to store context state; 0 = inactive, 1 = active
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDevicePrimaryCtxSetFlags\fP, \fBcuCtxGetFlags\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDevicePrimaryCtxRelease (\fBCUdevice\fP dev)"
.PP
Releases the primary context interop on the device by decreasing the usage count by 1. If the usage drops to 0 the primary context of device \fCdev\fP will be destroyed regardless of how many threads it is current to.
.PP
Please note that unlike \fBcuCtxDestroy()\fP this method does not pop the context from stack in any circumstances.
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP - Device which primary context is released
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDevicePrimaryCtxRetain\fP, \fBcuCtxDestroy\fP, \fBcuCtxGetApiVersion\fP, \fBcuCtxGetCacheConfig\fP, \fBcuCtxGetDevice\fP, \fBcuCtxGetFlags\fP, \fBcuCtxGetLimit\fP, \fBcuCtxPopCurrent\fP, \fBcuCtxPushCurrent\fP, \fBcuCtxSetCacheConfig\fP, \fBcuCtxSetLimit\fP, \fBcuCtxSynchronize\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDevicePrimaryCtxReset (\fBCUdevice\fP dev)"
.PP
Explicitly destroys and cleans up all resources associated with the current device in the current process.
.PP
Note that it is responsibility of the calling function to ensure that no other module in the process is using the device any more. For that reason it is recommended to use \fBcuDevicePrimaryCtxRelease()\fP in most cases. However it is safe for other modules to call \fBcuDevicePrimaryCtxRelease()\fP even after resetting the device.
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP - Device for which primary context is destroyed
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP, \fBCUDA_ERROR_PRIMARY_CONTEXT_ACTIVE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDevicePrimaryCtxRetain\fP, \fBcuDevicePrimaryCtxRelease\fP, \fBcuCtxGetApiVersion\fP, \fBcuCtxGetCacheConfig\fP, \fBcuCtxGetDevice\fP, \fBcuCtxGetFlags\fP, \fBcuCtxGetLimit\fP, \fBcuCtxPopCurrent\fP, \fBcuCtxPushCurrent\fP, \fBcuCtxSetCacheConfig\fP, \fBcuCtxSetLimit\fP, \fBcuCtxSynchronize\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDevicePrimaryCtxRetain (\fBCUcontext\fP * pctx, \fBCUdevice\fP dev)"
.PP
Retains the primary context on the device, creating it if necessary, increasing its usage count. The caller must call \fBcuDevicePrimaryCtxRelease()\fP when done using the context. Unlike \fBcuCtxCreate()\fP the newly created context is not pushed onto the stack.
.PP
Context creation will fail with \fBCUDA_ERROR_UNKNOWN\fP if the compute mode of the device is \fBCU_COMPUTEMODE_PROHIBITED\fP. The function \fBcuDeviceGetAttribute()\fP can be used with \fBCU_DEVICE_ATTRIBUTE_COMPUTE_MODE\fP to determine the compute mode of the device. The \fInvidia-smi\fP tool can be used to set the compute mode for devices. Documentation for \fInvidia-smi\fP can be obtained by passing a -h option to it.
.PP
Please note that the primary context always supports pinned allocations. Other flags can be specified by \fBcuDevicePrimaryCtxSetFlags()\fP.
.PP
\fBParameters:\fP
.RS 4
\fIpctx\fP - Returned context handle of the new context 
.br
\fIdev\fP - Device for which primary context is requested
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_CONTEXT\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_OUT_OF_MEMORY\fP, \fBCUDA_ERROR_UNKNOWN\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDevicePrimaryCtxRelease\fP, \fBcuDevicePrimaryCtxSetFlags\fP, \fBcuCtxCreate\fP, \fBcuCtxGetApiVersion\fP, \fBcuCtxGetCacheConfig\fP, \fBcuCtxGetDevice\fP, \fBcuCtxGetFlags\fP, \fBcuCtxGetLimit\fP, \fBcuCtxPopCurrent\fP, \fBcuCtxPushCurrent\fP, \fBcuCtxSetCacheConfig\fP, \fBcuCtxSetLimit\fP, \fBcuCtxSynchronize\fP 
.RE
.PP

.SS "\fBCUresult\fP cuDevicePrimaryCtxSetFlags (\fBCUdevice\fP dev, unsigned int flags)"
.PP
Sets the flags for the primary context on the device overwriting perviously set ones. If the primary context is already created \fBCUDA_ERROR_PRIMARY_CONTEXT_ACTIVE\fP is returned.
.PP
The three LSBs of the \fCflags\fP parameter can be used to control how the OS thread, which owns the CUDA context at the time of an API call, interacts with the OS scheduler when waiting for results from the GPU. Only one of the scheduling flags can be set when creating a context.
.PP
.IP "\(bu" 2
\fBCU_CTX_SCHED_SPIN\fP: Instruct CUDA to actively spin when waiting for results from the GPU. This can decrease latency when waiting for the GPU, but may lower the performance of CPU threads if they are performing work in parallel with the CUDA thread.
.PP
.PP
.IP "\(bu" 2
\fBCU_CTX_SCHED_YIELD\fP: Instruct CUDA to yield its thread when waiting for results from the GPU. This can increase latency when waiting for the GPU, but can increase the performance of CPU threads performing work in parallel with the GPU.
.PP
.PP
.IP "\(bu" 2
\fBCU_CTX_SCHED_BLOCKING_SYNC\fP: Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.
.PP
.PP
.IP "\(bu" 2
\fBCU_CTX_BLOCKING_SYNC\fP: Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work. 
.br
 \fBDeprecated:\fP This flag was deprecated as of CUDA 4.0 and was replaced with \fBCU_CTX_SCHED_BLOCKING_SYNC\fP.
.PP
.PP
.IP "\(bu" 2
\fBCU_CTX_SCHED_AUTO\fP: The default value if the \fCflags\fP parameter is zero, uses a heuristic based on the number of active CUDA contexts in the process \fIC\fP and the number of logical processors in the system \fIP\fP. If \fIC\fP > \fIP\fP, then CUDA will yield to other OS threads when waiting for the GPU (\fBCU_CTX_SCHED_YIELD\fP), otherwise CUDA will not yield while waiting for results and actively spin on the processor (\fBCU_CTX_SCHED_SPIN\fP). However, on low power devices like Tegra, it always defaults to \fBCU_CTX_SCHED_BLOCKING_SYNC\fP.
.PP
.PP
.IP "\(bu" 2
\fBCU_CTX_LMEM_RESIZE_TO_MAX\fP: Instruct CUDA to not reduce local memory after resizing local memory for a kernel. This can prevent thrashing by local memory allocations when launching many kernels with high local memory usage at the cost of potentially increased memory usage.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP - Device for which the primary context flags are set 
.br
\fIflags\fP - New flags for the device
.RE
.PP
\fBReturns:\fP
.RS 4
\fBCUDA_SUCCESS\fP, \fBCUDA_ERROR_DEINITIALIZED\fP, \fBCUDA_ERROR_NOT_INITIALIZED\fP, \fBCUDA_ERROR_INVALID_DEVICE\fP, \fBCUDA_ERROR_INVALID_VALUE\fP, \fBCUDA_ERROR_PRIMARY_CONTEXT_ACTIVE\fP 
.RE
.PP
\fBNote:\fP
.RS 4
Note that this function may also return error codes from previous, asynchronous launches.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcuDevicePrimaryCtxRetain\fP, \fBcuDevicePrimaryCtxGetState\fP, \fBcuCtxCreate\fP, \fBcuCtxGetFlags\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code.
