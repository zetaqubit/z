.TH "Data types used by CUDA driver" 3 "12 Jan 2017" "Version 6.0" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Data types used by CUDA driver \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBCUDA_ARRAY3D_DESCRIPTOR\fP"
.br
.ti -1c
.RI "struct \fBCUDA_ARRAY_DESCRIPTOR\fP"
.br
.ti -1c
.RI "struct \fBCUDA_MEMCPY2D\fP"
.br
.ti -1c
.RI "struct \fBCUDA_MEMCPY3D\fP"
.br
.ti -1c
.RI "struct \fBCUDA_MEMCPY3D_PEER\fP"
.br
.ti -1c
.RI "struct \fBCUDA_POINTER_ATTRIBUTE_P2P_TOKENS\fP"
.br
.ti -1c
.RI "struct \fBCUDA_RESOURCE_DESC\fP"
.br
.ti -1c
.RI "struct \fBCUDA_RESOURCE_VIEW_DESC\fP"
.br
.ti -1c
.RI "struct \fBCUDA_TEXTURE_DESC\fP"
.br
.ti -1c
.RI "struct \fBCUdevprop\fP"
.br
.ti -1c
.RI "struct \fBCUeglFrame\fP"
.br
.ti -1c
.RI "struct \fBCUipcEventHandle\fP"
.br
.ti -1c
.RI "struct \fBCUipcMemHandle\fP"
.br
.ti -1c
.RI "union \fBCUstreamBatchMemOpParams\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBCU_DEVICE_CPU\fP   ((\fBCUdevice\fP)-1)"
.br
.ti -1c
.RI "#define \fBCU_DEVICE_INVALID\fP   ((\fBCUdevice\fP)-2)"
.br
.ti -1c
.RI "#define \fBCU_IPC_HANDLE_SIZE\fP   64"
.br
.ti -1c
.RI "#define \fBCU_LAUNCH_PARAM_BUFFER_POINTER\fP   ((void*)0x01)"
.br
.ti -1c
.RI "#define \fBCU_LAUNCH_PARAM_BUFFER_SIZE\fP   ((void*)0x02)"
.br
.ti -1c
.RI "#define \fBCU_LAUNCH_PARAM_END\fP   ((void*)0x00)"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTALLOC_DEVICEMAP\fP   0x02"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTALLOC_PORTABLE\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTALLOC_WRITECOMBINED\fP   0x04"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTREGISTER_DEVICEMAP\fP   0x02"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTREGISTER_IOMEMORY\fP   0x04"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTREGISTER_PORTABLE\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_PARAM_TR_DEFAULT\fP   -1"
.br
.ti -1c
.RI "#define \fBCU_STREAM_LEGACY\fP   ((\fBCUstream\fP)0x1)"
.br
.ti -1c
.RI "#define \fBCU_STREAM_PER_THREAD\fP   ((\fBCUstream\fP)0x2)"
.br
.ti -1c
.RI "#define \fBCU_TRSA_OVERRIDE_FORMAT\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_TRSF_NORMALIZED_COORDINATES\fP   0x02"
.br
.ti -1c
.RI "#define \fBCU_TRSF_READ_AS_INTEGER\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_TRSF_SRGB\fP   0x10"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_2DARRAY\fP   0x01"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_CUBEMAP\fP   0x04"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_DEPTH_TEXTURE\fP   0x10"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_LAYERED\fP   0x01"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_SURFACE_LDST\fP   0x02"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_TEXTURE_GATHER\fP   0x08"
.br
.ti -1c
.RI "#define \fBCUDA_VERSION\fP   8000"
.br
.ti -1c
.RI "#define \fBMAX_PLANES\fP   3"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct CUarray_st * \fBCUarray\fP"
.br
.ti -1c
.RI "typedef struct CUctx_st * \fBCUcontext\fP"
.br
.ti -1c
.RI "typedef int \fBCUdevice\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBCUdeviceptr\fP"
.br
.ti -1c
.RI "typedef struct CUeglStreamConnection_st * \fBCUeglStreamConnection\fP"
.br
.ti -1c
.RI "typedef struct CUevent_st * \fBCUevent\fP"
.br
.ti -1c
.RI "typedef struct CUfunc_st * \fBCUfunction\fP"
.br
.ti -1c
.RI "typedef struct CUgraphicsResource_st * \fBCUgraphicsResource\fP"
.br
.ti -1c
.RI "typedef struct CUmipmappedArray_st * \fBCUmipmappedArray\fP"
.br
.ti -1c
.RI "typedef struct CUmod_st * \fBCUmodule\fP"
.br
.ti -1c
.RI "typedef size_t(CUDA_CB * \fBCUoccupancyB2DSize\fP )(int blockSize)"
.br
.ti -1c
.RI "typedef struct CUstream_st * \fBCUstream\fP"
.br
.ti -1c
.RI "typedef void(CUDA_CB * \fBCUstreamCallback\fP )(\fBCUstream\fP hStream, \fBCUresult\fP status, void *userData)"
.br
.ti -1c
.RI "typedef unsigned long long \fBCUsurfObject\fP"
.br
.ti -1c
.RI "typedef struct CUsurfref_st * \fBCUsurfref\fP"
.br
.ti -1c
.RI "typedef unsigned long long \fBCUtexObject\fP"
.br
.ti -1c
.RI "typedef struct CUtexref_st * \fBCUtexref\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBCUaddress_mode\fP { \fBCU_TR_ADDRESS_MODE_WRAP\fP =  0, \fBCU_TR_ADDRESS_MODE_CLAMP\fP =  1, \fBCU_TR_ADDRESS_MODE_MIRROR\fP =  2, \fBCU_TR_ADDRESS_MODE_BORDER\fP =  3 }"
.br
.ti -1c
.RI "enum \fBCUarray_cubemap_face\fP { \fBCU_CUBEMAP_FACE_POSITIVE_X\fP =  0x00, \fBCU_CUBEMAP_FACE_NEGATIVE_X\fP =  0x01, \fBCU_CUBEMAP_FACE_POSITIVE_Y\fP =  0x02, \fBCU_CUBEMAP_FACE_NEGATIVE_Y\fP =  0x03, \fBCU_CUBEMAP_FACE_POSITIVE_Z\fP =  0x04, \fBCU_CUBEMAP_FACE_NEGATIVE_Z\fP =  0x05 }"
.br
.ti -1c
.RI "enum \fBCUarray_format\fP { \fBCU_AD_FORMAT_UNSIGNED_INT8\fP =  0x01, \fBCU_AD_FORMAT_UNSIGNED_INT16\fP =  0x02, \fBCU_AD_FORMAT_UNSIGNED_INT32\fP =  0x03, \fBCU_AD_FORMAT_SIGNED_INT8\fP =  0x08, \fBCU_AD_FORMAT_SIGNED_INT16\fP =  0x09, \fBCU_AD_FORMAT_SIGNED_INT32\fP =  0x0a, \fBCU_AD_FORMAT_HALF\fP =  0x10, \fBCU_AD_FORMAT_FLOAT\fP =  0x20 }"
.br
.ti -1c
.RI "enum \fBCUcomputemode\fP { \fBCU_COMPUTEMODE_DEFAULT\fP =  0, \fBCU_COMPUTEMODE_PROHIBITED\fP =  2, \fBCU_COMPUTEMODE_EXCLUSIVE_PROCESS\fP =  3 }"
.br
.ti -1c
.RI "enum \fBCUctx_flags\fP { \fBCU_CTX_SCHED_AUTO\fP =  0x00, \fBCU_CTX_SCHED_SPIN\fP =  0x01, \fBCU_CTX_SCHED_YIELD\fP =  0x02, \fBCU_CTX_SCHED_BLOCKING_SYNC\fP =  0x04, \fBCU_CTX_BLOCKING_SYNC\fP =  0x04, \fBCU_CTX_MAP_HOST\fP =  0x08, \fBCU_CTX_LMEM_RESIZE_TO_MAX\fP =  0x10 }"
.br
.ti -1c
.RI "enum \fBCUdevice_attribute\fP { \fBCU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK\fP =  1, \fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X\fP =  2, \fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y\fP =  3, \fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z\fP =  4, \fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X\fP =  5, \fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y\fP =  6, \fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z\fP =  7, \fBCU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK\fP =  8, \fBCU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK\fP =  8, \fBCU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY\fP =  9, \fBCU_DEVICE_ATTRIBUTE_WARP_SIZE\fP =  10, \fBCU_DEVICE_ATTRIBUTE_MAX_PITCH\fP =  11, \fBCU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK\fP =  12, \fBCU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK\fP =  12, \fBCU_DEVICE_ATTRIBUTE_CLOCK_RATE\fP =  13, \fBCU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT\fP =  14, \fBCU_DEVICE_ATTRIBUTE_GPU_OVERLAP\fP =  15, \fBCU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT\fP =  16, \fBCU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT\fP =  17, \fBCU_DEVICE_ATTRIBUTE_INTEGRATED\fP =  18, \fBCU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY\fP =  19, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_MODE\fP =  20, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH\fP =  21, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH\fP =  22, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT\fP =  23, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH\fP =  24, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT\fP =  25, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH\fP =  26, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH\fP =  27, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT\fP =  28, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS\fP =  29, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH\fP =  27, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT\fP =  28, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES\fP =  29, \fBCU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT\fP =  30, \fBCU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS\fP =  31, \fBCU_DEVICE_ATTRIBUTE_ECC_ENABLED\fP =  32, \fBCU_DEVICE_ATTRIBUTE_PCI_BUS_ID\fP =  33, \fBCU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID\fP =  34, \fBCU_DEVICE_ATTRIBUTE_TCC_DRIVER\fP =  35, \fBCU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE\fP =  36, \fBCU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH\fP =  37, \fBCU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE\fP =  38, \fBCU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR\fP =  39, \fBCU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT\fP =  40, \fBCU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING\fP =  41, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH\fP =  42, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS\fP =  43, \fBCU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER\fP =  44, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH\fP =  45, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT\fP =  46, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE\fP =  47, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE\fP =  48, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE\fP =  49, \fBCU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID\fP =  50, \fBCU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT\fP =  51, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH\fP =  52, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH\fP =  53, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS\fP =  54, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH\fP =  55, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH\fP =  56, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT\fP =  57, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH\fP =  58, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT\fP =  59, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH\fP =  60, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH\fP =  61, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS\fP =  62, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH\fP =  63, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT\fP =  64, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS\fP =  65, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH\fP =  66, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH\fP =  67, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS\fP =  68, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH\fP =  69, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH\fP =  70, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT\fP =  71, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH\fP =  72, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH\fP =  73, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT\fP =  74, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR\fP =  75, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR\fP =  76, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH\fP =  77, \fBCU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED\fP =  78, \fBCU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED\fP =  79, \fBCU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED\fP =  80, \fBCU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR\fP =  81, \fBCU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR\fP =  82, \fBCU_DEVICE_ATTRIBUTE_MANAGED_MEMORY\fP =  83, \fBCU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD\fP =  84, \fBCU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID\fP =  85, \fBCU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED\fP =  86, \fBCU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO\fP =  87, \fBCU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS\fP =  88, \fBCU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS\fP =  89, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED\fP =  90, \fBCU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM\fP =  91 }"
.br
.ti -1c
.RI "enum \fBCUdevice_P2PAttribute\fP { \fBCU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK\fP =  0x01, \fBCU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED\fP =  0x02, \fBCU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED\fP =  0x03 }"
.br
.ti -1c
.RI "enum \fBCUeglColorFormat\fP { \fBCU_EGL_COLOR_FORMAT_YUV420_PLANAR\fP =  0x00, \fBCU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR\fP =  0x01, \fBCU_EGL_COLOR_FORMAT_YUV422_PLANAR\fP =  0x02, \fBCU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR\fP =  0x03, \fBCU_EGL_COLOR_FORMAT_RGB\fP =  0x04, \fBCU_EGL_COLOR_FORMAT_BGR\fP =  0x05, \fBCU_EGL_COLOR_FORMAT_ARGB\fP =  0x06, \fBCU_EGL_COLOR_FORMAT_RGBA\fP =  0x07, \fBCU_EGL_COLOR_FORMAT_L\fP =  0x08, \fBCU_EGL_COLOR_FORMAT_R\fP =  0x09 }"
.br
.ti -1c
.RI "enum \fBCUeglFrameType\fP { \fBCU_EGL_FRAME_TYPE_ARRAY\fP =  0, \fBCU_EGL_FRAME_TYPE_PITCH\fP =  1 }"
.br
.ti -1c
.RI "enum \fBCUeglResourceLocationFlags\fP { \fBCU_EGL_RESOURCE_LOCATION_SYSMEM\fP =  0x00, \fBCU_EGL_RESOURCE_LOCATION_VIDMEM\fP =  0x01 }"
.br
.ti -1c
.RI "enum \fBCUevent_flags\fP { \fBCU_EVENT_DEFAULT\fP =  0x0, \fBCU_EVENT_BLOCKING_SYNC\fP =  0x1, \fBCU_EVENT_DISABLE_TIMING\fP =  0x2, \fBCU_EVENT_INTERPROCESS\fP =  0x4 }"
.br
.ti -1c
.RI "enum \fBCUfilter_mode\fP { \fBCU_TR_FILTER_MODE_POINT\fP =  0, \fBCU_TR_FILTER_MODE_LINEAR\fP =  1 }"
.br
.ti -1c
.RI "enum \fBCUfunc_cache\fP { \fBCU_FUNC_CACHE_PREFER_NONE\fP =  0x00, \fBCU_FUNC_CACHE_PREFER_SHARED\fP =  0x01, \fBCU_FUNC_CACHE_PREFER_L1\fP =  0x02, \fBCU_FUNC_CACHE_PREFER_EQUAL\fP =  0x03 }"
.br
.ti -1c
.RI "enum \fBCUfunction_attribute\fP { \fBCU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK\fP =  0, \fBCU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES\fP =  1, \fBCU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES\fP =  2, \fBCU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES\fP =  3, \fBCU_FUNC_ATTRIBUTE_NUM_REGS\fP =  4, \fBCU_FUNC_ATTRIBUTE_PTX_VERSION\fP =  5, \fBCU_FUNC_ATTRIBUTE_BINARY_VERSION\fP =  6, \fBCU_FUNC_ATTRIBUTE_CACHE_MODE_CA\fP =  7 }"
.br
.ti -1c
.RI "enum \fBCUgraphicsMapResourceFlags\fP "
.br
.ti -1c
.RI "enum \fBCUgraphicsRegisterFlags\fP "
.br
.ti -1c
.RI "enum \fBCUipcMem_flags\fP { \fBCU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS\fP =  0x1 }"
.br
.ti -1c
.RI "enum \fBCUjit_cacheMode\fP { \fBCU_JIT_CACHE_OPTION_NONE\fP =  0, \fBCU_JIT_CACHE_OPTION_CG\fP, \fBCU_JIT_CACHE_OPTION_CA\fP }"
.br
.ti -1c
.RI "enum \fBCUjit_fallback\fP { \fBCU_PREFER_PTX\fP =  0, \fBCU_PREFER_BINARY\fP }"
.br
.ti -1c
.RI "enum \fBCUjit_option\fP { \fBCU_JIT_MAX_REGISTERS\fP =  0, \fBCU_JIT_THREADS_PER_BLOCK\fP, \fBCU_JIT_WALL_TIME\fP, \fBCU_JIT_INFO_LOG_BUFFER\fP, \fBCU_JIT_INFO_LOG_BUFFER_SIZE_BYTES\fP, \fBCU_JIT_ERROR_LOG_BUFFER\fP, \fBCU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES\fP, \fBCU_JIT_OPTIMIZATION_LEVEL\fP, \fBCU_JIT_TARGET_FROM_CUCONTEXT\fP, \fBCU_JIT_TARGET\fP, \fBCU_JIT_FALLBACK_STRATEGY\fP, \fBCU_JIT_GENERATE_DEBUG_INFO\fP, \fBCU_JIT_LOG_VERBOSE\fP, \fBCU_JIT_GENERATE_LINE_INFO\fP, \fBCU_JIT_CACHE_MODE\fP, \fBCU_JIT_NEW_SM3X_OPT\fP }"
.br
.ti -1c
.RI "enum \fBCUjit_target\fP { \fBCU_TARGET_COMPUTE_10\fP =  10, \fBCU_TARGET_COMPUTE_11\fP =  11, \fBCU_TARGET_COMPUTE_12\fP =  12, \fBCU_TARGET_COMPUTE_13\fP =  13, \fBCU_TARGET_COMPUTE_20\fP =  20, \fBCU_TARGET_COMPUTE_21\fP =  21, \fBCU_TARGET_COMPUTE_30\fP =  30, \fBCU_TARGET_COMPUTE_32\fP =  32, \fBCU_TARGET_COMPUTE_35\fP =  35, \fBCU_TARGET_COMPUTE_37\fP =  37, \fBCU_TARGET_COMPUTE_50\fP =  50, \fBCU_TARGET_COMPUTE_52\fP =  52, \fBCU_TARGET_COMPUTE_53\fP =  53, \fBCU_TARGET_COMPUTE_60\fP =  60, \fBCU_TARGET_COMPUTE_61\fP =  61, \fBCU_TARGET_COMPUTE_62\fP =  62 }"
.br
.ti -1c
.RI "enum \fBCUjitInputType\fP { \fBCU_JIT_INPUT_CUBIN\fP =  0, \fBCU_JIT_INPUT_PTX\fP, \fBCU_JIT_INPUT_FATBINARY\fP, \fBCU_JIT_INPUT_OBJECT\fP, \fBCU_JIT_INPUT_LIBRARY\fP }"
.br
.ti -1c
.RI "enum \fBCUlimit\fP { \fBCU_LIMIT_STACK_SIZE\fP =  0x00, \fBCU_LIMIT_PRINTF_FIFO_SIZE\fP =  0x01, \fBCU_LIMIT_MALLOC_HEAP_SIZE\fP =  0x02, \fBCU_LIMIT_DEV_RUNTIME_SYNC_DEPTH\fP =  0x03, \fBCU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT\fP =  0x04 }"
.br
.ti -1c
.RI "enum \fBCUmem_advise\fP { \fBCU_MEM_ADVISE_SET_READ_MOSTLY\fP =  1, \fBCU_MEM_ADVISE_UNSET_READ_MOSTLY\fP =  2, \fBCU_MEM_ADVISE_SET_PREFERRED_LOCATION\fP =  3, \fBCU_MEM_ADVISE_UNSET_PREFERRED_LOCATION\fP =  4, \fBCU_MEM_ADVISE_SET_ACCESSED_BY\fP =  5, \fBCU_MEM_ADVISE_UNSET_ACCESSED_BY\fP =  6 }"
.br
.ti -1c
.RI "enum \fBCUmem_range_attribute\fP { \fBCU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY\fP =  1, \fBCU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION\fP =  2, \fBCU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY\fP =  3, \fBCU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION\fP =  4 }"
.br
.ti -1c
.RI "enum \fBCUmemAttach_flags\fP { \fBCU_MEM_ATTACH_GLOBAL\fP =  0x1, \fBCU_MEM_ATTACH_HOST\fP =  0x2, \fBCU_MEM_ATTACH_SINGLE\fP =  0x4 }"
.br
.ti -1c
.RI "enum \fBCUmemorytype\fP { \fBCU_MEMORYTYPE_HOST\fP =  0x01, \fBCU_MEMORYTYPE_DEVICE\fP =  0x02, \fBCU_MEMORYTYPE_ARRAY\fP =  0x03, \fBCU_MEMORYTYPE_UNIFIED\fP =  0x04 }"
.br
.ti -1c
.RI "enum \fBCUoccupancy_flags\fP { \fBCU_OCCUPANCY_DEFAULT\fP =  0x0, \fBCU_OCCUPANCY_DISABLE_CACHING_OVERRIDE\fP =  0x1 }"
.br
.ti -1c
.RI "enum \fBCUpointer_attribute\fP { \fBCU_POINTER_ATTRIBUTE_CONTEXT\fP =  1, \fBCU_POINTER_ATTRIBUTE_MEMORY_TYPE\fP =  2, \fBCU_POINTER_ATTRIBUTE_DEVICE_POINTER\fP =  3, \fBCU_POINTER_ATTRIBUTE_HOST_POINTER\fP =  4, \fBCU_POINTER_ATTRIBUTE_P2P_TOKENS\fP =  5, \fBCU_POINTER_ATTRIBUTE_SYNC_MEMOPS\fP =  6, \fBCU_POINTER_ATTRIBUTE_BUFFER_ID\fP =  7, \fBCU_POINTER_ATTRIBUTE_IS_MANAGED\fP =  8 }"
.br
.ti -1c
.RI "enum \fBCUresourcetype\fP { \fBCU_RESOURCE_TYPE_ARRAY\fP =  0x00, \fBCU_RESOURCE_TYPE_MIPMAPPED_ARRAY\fP =  0x01, \fBCU_RESOURCE_TYPE_LINEAR\fP =  0x02, \fBCU_RESOURCE_TYPE_PITCH2D\fP =  0x03 }"
.br
.ti -1c
.RI "enum \fBCUresourceViewFormat\fP { \fBCU_RES_VIEW_FORMAT_NONE\fP =  0x00, \fBCU_RES_VIEW_FORMAT_UINT_1X8\fP =  0x01, \fBCU_RES_VIEW_FORMAT_UINT_2X8\fP =  0x02, \fBCU_RES_VIEW_FORMAT_UINT_4X8\fP =  0x03, \fBCU_RES_VIEW_FORMAT_SINT_1X8\fP =  0x04, \fBCU_RES_VIEW_FORMAT_SINT_2X8\fP =  0x05, \fBCU_RES_VIEW_FORMAT_SINT_4X8\fP =  0x06, \fBCU_RES_VIEW_FORMAT_UINT_1X16\fP =  0x07, \fBCU_RES_VIEW_FORMAT_UINT_2X16\fP =  0x08, \fBCU_RES_VIEW_FORMAT_UINT_4X16\fP =  0x09, \fBCU_RES_VIEW_FORMAT_SINT_1X16\fP =  0x0a, \fBCU_RES_VIEW_FORMAT_SINT_2X16\fP =  0x0b, \fBCU_RES_VIEW_FORMAT_SINT_4X16\fP =  0x0c, \fBCU_RES_VIEW_FORMAT_UINT_1X32\fP =  0x0d, \fBCU_RES_VIEW_FORMAT_UINT_2X32\fP =  0x0e, \fBCU_RES_VIEW_FORMAT_UINT_4X32\fP =  0x0f, \fBCU_RES_VIEW_FORMAT_SINT_1X32\fP =  0x10, \fBCU_RES_VIEW_FORMAT_SINT_2X32\fP =  0x11, \fBCU_RES_VIEW_FORMAT_SINT_4X32\fP =  0x12, \fBCU_RES_VIEW_FORMAT_FLOAT_1X16\fP =  0x13, \fBCU_RES_VIEW_FORMAT_FLOAT_2X16\fP =  0x14, \fBCU_RES_VIEW_FORMAT_FLOAT_4X16\fP =  0x15, \fBCU_RES_VIEW_FORMAT_FLOAT_1X32\fP =  0x16, \fBCU_RES_VIEW_FORMAT_FLOAT_2X32\fP =  0x17, \fBCU_RES_VIEW_FORMAT_FLOAT_4X32\fP =  0x18, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC1\fP =  0x19, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC2\fP =  0x1a, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC3\fP =  0x1b, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC4\fP =  0x1c, \fBCU_RES_VIEW_FORMAT_SIGNED_BC4\fP =  0x1d, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC5\fP =  0x1e, \fBCU_RES_VIEW_FORMAT_SIGNED_BC5\fP =  0x1f, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC6H\fP =  0x20, \fBCU_RES_VIEW_FORMAT_SIGNED_BC6H\fP =  0x21, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC7\fP =  0x22 }"
.br
.ti -1c
.RI "enum \fBCUresult\fP { \fBCUDA_SUCCESS\fP =  0, \fBCUDA_ERROR_INVALID_VALUE\fP =  1, \fBCUDA_ERROR_OUT_OF_MEMORY\fP =  2, \fBCUDA_ERROR_NOT_INITIALIZED\fP =  3, \fBCUDA_ERROR_DEINITIALIZED\fP =  4, \fBCUDA_ERROR_PROFILER_DISABLED\fP =  5, \fBCUDA_ERROR_PROFILER_NOT_INITIALIZED\fP =  6, \fBCUDA_ERROR_PROFILER_ALREADY_STARTED\fP =  7, \fBCUDA_ERROR_PROFILER_ALREADY_STOPPED\fP =  8, \fBCUDA_ERROR_NO_DEVICE\fP =  100, \fBCUDA_ERROR_INVALID_DEVICE\fP =  101, \fBCUDA_ERROR_INVALID_IMAGE\fP =  200, \fBCUDA_ERROR_INVALID_CONTEXT\fP =  201, \fBCUDA_ERROR_CONTEXT_ALREADY_CURRENT\fP =  202, \fBCUDA_ERROR_MAP_FAILED\fP =  205, \fBCUDA_ERROR_UNMAP_FAILED\fP =  206, \fBCUDA_ERROR_ARRAY_IS_MAPPED\fP =  207, \fBCUDA_ERROR_ALREADY_MAPPED\fP =  208, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP =  209, \fBCUDA_ERROR_ALREADY_ACQUIRED\fP =  210, \fBCUDA_ERROR_NOT_MAPPED\fP =  211, \fBCUDA_ERROR_NOT_MAPPED_AS_ARRAY\fP =  212, \fBCUDA_ERROR_NOT_MAPPED_AS_POINTER\fP =  213, \fBCUDA_ERROR_ECC_UNCORRECTABLE\fP =  214, \fBCUDA_ERROR_UNSUPPORTED_LIMIT\fP =  215, \fBCUDA_ERROR_CONTEXT_ALREADY_IN_USE\fP =  216, \fBCUDA_ERROR_PEER_ACCESS_UNSUPPORTED\fP =  217, \fBCUDA_ERROR_INVALID_PTX\fP =  218, \fBCUDA_ERROR_INVALID_GRAPHICS_CONTEXT\fP =  219, \fBCUDA_ERROR_NVLINK_UNCORRECTABLE\fP =  220, \fBCUDA_ERROR_INVALID_SOURCE\fP =  300, \fBCUDA_ERROR_FILE_NOT_FOUND\fP =  301, \fBCUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND\fP =  302, \fBCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\fP =  303, \fBCUDA_ERROR_OPERATING_SYSTEM\fP =  304, \fBCUDA_ERROR_INVALID_HANDLE\fP =  400, \fBCUDA_ERROR_NOT_FOUND\fP =  500, \fBCUDA_ERROR_NOT_READY\fP =  600, \fBCUDA_ERROR_ILLEGAL_ADDRESS\fP =  700, \fBCUDA_ERROR_LAUNCH_OUT_OF_RESOURCES\fP =  701, \fBCUDA_ERROR_LAUNCH_TIMEOUT\fP =  702, \fBCUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING\fP =  703, \fBCUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED\fP =  704, \fBCUDA_ERROR_PEER_ACCESS_NOT_ENABLED\fP =  705, \fBCUDA_ERROR_PRIMARY_CONTEXT_ACTIVE\fP =  708, \fBCUDA_ERROR_CONTEXT_IS_DESTROYED\fP =  709, \fBCUDA_ERROR_ASSERT\fP =  710, \fBCUDA_ERROR_TOO_MANY_PEERS\fP =  711, \fBCUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED\fP =  712, \fBCUDA_ERROR_HOST_MEMORY_NOT_REGISTERED\fP =  713, \fBCUDA_ERROR_HARDWARE_STACK_ERROR\fP =  714, \fBCUDA_ERROR_ILLEGAL_INSTRUCTION\fP =  715, \fBCUDA_ERROR_MISALIGNED_ADDRESS\fP =  716, \fBCUDA_ERROR_INVALID_ADDRESS_SPACE\fP =  717, \fBCUDA_ERROR_INVALID_PC\fP =  718, \fBCUDA_ERROR_LAUNCH_FAILED\fP =  719, \fBCUDA_ERROR_NOT_PERMITTED\fP =  800, \fBCUDA_ERROR_NOT_SUPPORTED\fP =  801, \fBCUDA_ERROR_UNKNOWN\fP =  999 }"
.br
.ti -1c
.RI "enum \fBCUsharedconfig\fP { \fBCU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE\fP =  0x00, \fBCU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE\fP =  0x01, \fBCU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE\fP =  0x02 }"
.br
.ti -1c
.RI "enum \fBCUstream_flags\fP { \fBCU_STREAM_DEFAULT\fP =  0x0, \fBCU_STREAM_NON_BLOCKING\fP =  0x1 }"
.br
.ti -1c
.RI "enum \fBCUstreamBatchMemOpType\fP { \fBCU_STREAM_MEM_OP_WAIT_VALUE_32\fP =  1, \fBCU_STREAM_MEM_OP_WRITE_VALUE_32\fP =  2, \fBCU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES\fP =  3 }"
.br
.ti -1c
.RI "enum \fBCUstreamWaitValue_flags\fP { \fBCU_STREAM_WAIT_VALUE_GEQ\fP =  0x0, \fBCU_STREAM_WAIT_VALUE_EQ\fP =  0x1, \fBCU_STREAM_WAIT_VALUE_AND\fP =  0x2, \fBCU_STREAM_WAIT_VALUE_FLUSH\fP =  1<<30 }"
.br
.ti -1c
.RI "enum \fBCUstreamWriteValue_flags\fP { \fBCU_STREAM_WRITE_VALUE_DEFAULT\fP =  0x0, \fBCU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER\fP =  0x1 }"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define CU_DEVICE_CPU   ((\fBCUdevice\fP)-1)"
.PP
Device that represents the CPU 
.SS "#define CU_DEVICE_INVALID   ((\fBCUdevice\fP)-2)"
.PP
Device that represents an invalid device 
.SS "#define CU_IPC_HANDLE_SIZE   64"
.PP
CUDA IPC handle size 
.SS "#define CU_LAUNCH_PARAM_BUFFER_POINTER   ((void*)0x01)"
.PP
Indicator that the next value in the \fCextra\fP parameter to \fBcuLaunchKernel\fP will be a pointer to a buffer containing all kernel parameters used for launching kernel \fCf\fP. This buffer needs to honor all alignment/padding requirements of the individual parameters. If \fBCU_LAUNCH_PARAM_BUFFER_SIZE\fP is not also specified in the \fCextra\fP array, then \fBCU_LAUNCH_PARAM_BUFFER_POINTER\fP will have no effect. 
.SS "#define CU_LAUNCH_PARAM_BUFFER_SIZE   ((void*)0x02)"
.PP
Indicator that the next value in the \fCextra\fP parameter to \fBcuLaunchKernel\fP will be a pointer to a size_t which contains the size of the buffer specified with \fBCU_LAUNCH_PARAM_BUFFER_POINTER\fP. It is required that \fBCU_LAUNCH_PARAM_BUFFER_POINTER\fP also be specified in the \fCextra\fP array if the value associated with \fBCU_LAUNCH_PARAM_BUFFER_SIZE\fP is not zero. 
.SS "#define CU_LAUNCH_PARAM_END   ((void*)0x00)"
.PP
End of array terminator for the \fCextra\fP parameter to \fBcuLaunchKernel\fP 
.SS "#define CU_MEMHOSTALLOC_DEVICEMAP   0x02"
.PP
If set, host memory is mapped into CUDA address space and \fBcuMemHostGetDevicePointer()\fP may be called on the host pointer. Flag for \fBcuMemHostAlloc()\fP 
.SS "#define CU_MEMHOSTALLOC_PORTABLE   0x01"
.PP
If set, host memory is portable between CUDA contexts. Flag for \fBcuMemHostAlloc()\fP 
.SS "#define CU_MEMHOSTALLOC_WRITECOMBINED   0x04"
.PP
If set, host memory is allocated as write-combined - fast to write, faster to DMA, slow to read except via SSE4 streaming load instruction (MOVNTDQA). Flag for \fBcuMemHostAlloc()\fP 
.SS "#define CU_MEMHOSTREGISTER_DEVICEMAP   0x02"
.PP
If set, host memory is mapped into CUDA address space and \fBcuMemHostGetDevicePointer()\fP may be called on the host pointer. Flag for \fBcuMemHostRegister()\fP 
.SS "#define CU_MEMHOSTREGISTER_IOMEMORY   0x04"
.PP
If set, the passed memory pointer is treated as pointing to some memory-mapped I/O space, e.g. belonging to a third-party PCIe device. On Windows the flag is a no-op. On Linux that memory is marked as non cache-coherent for the GPU and is expected to be physically contiguous. It may return CUDA_ERROR_NOT_PERMITTED if run as an unprivileged user, CUDA_ERROR_NOT_SUPPORTED on older Linux kernel versions. On all other platforms, it is not supported and CUDA_ERROR_NOT_SUPPORTED is returned. Flag for \fBcuMemHostRegister()\fP 
.SS "#define CU_MEMHOSTREGISTER_PORTABLE   0x01"
.PP
If set, host memory is portable between CUDA contexts. Flag for \fBcuMemHostRegister()\fP 
.SS "#define CU_PARAM_TR_DEFAULT   -1"
.PP
For texture references loaded into the module, use default texunit from texture reference. 
.SS "#define CU_STREAM_LEGACY   ((\fBCUstream\fP)0x1)"
.PP
Legacy stream handle
.PP
Stream handle that can be passed as a CUstream to use an implicit stream with legacy synchronization behavior.
.PP
See details of the . 
.SS "#define CU_STREAM_PER_THREAD   ((\fBCUstream\fP)0x2)"
.PP
Per-thread stream handle
.PP
Stream handle that can be passed as a CUstream to use an implicit stream with per-thread synchronization behavior.
.PP
See details of the . 
.SS "#define CU_TRSA_OVERRIDE_FORMAT   0x01"
.PP
Override the texref format with a format inferred from the array. Flag for \fBcuTexRefSetArray()\fP 
.SS "#define CU_TRSF_NORMALIZED_COORDINATES   0x02"
.PP
Use normalized texture coordinates in the range [0,1) instead of [0,dim). Flag for \fBcuTexRefSetFlags()\fP 
.SS "#define CU_TRSF_READ_AS_INTEGER   0x01"
.PP
Read the texture as integers rather than promoting the values to floats in the range [0,1]. Flag for \fBcuTexRefSetFlags()\fP 
.SS "#define CU_TRSF_SRGB   0x10"
.PP
Perform sRGB->linear conversion during texture read. Flag for \fBcuTexRefSetFlags()\fP 
.SS "#define CUDA_ARRAY3D_2DARRAY   0x01"
.PP
Deprecated, use CUDA_ARRAY3D_LAYERED 
.SS "#define CUDA_ARRAY3D_CUBEMAP   0x04"
.PP
If set, the CUDA array is a collection of six 2D arrays, representing faces of a cube. The width of such a CUDA array must be equal to its height, and Depth must be six. If \fBCUDA_ARRAY3D_LAYERED\fP flag is also set, then the CUDA array is a collection of cubemaps and Depth must be a multiple of six. 
.SS "#define CUDA_ARRAY3D_DEPTH_TEXTURE   0x10"
.PP
This flag if set indicates that the CUDA array is a DEPTH_TEXTURE. 
.SS "#define CUDA_ARRAY3D_LAYERED   0x01"
.PP
If set, the CUDA array is a collection of layers, where each layer is either a 1D or a 2D array and the Depth member of \fBCUDA_ARRAY3D_DESCRIPTOR\fP specifies the number of layers, not the depth of a 3D array. 
.SS "#define CUDA_ARRAY3D_SURFACE_LDST   0x02"
.PP
This flag must be set in order to bind a surface reference to the CUDA array 
.SS "#define CUDA_ARRAY3D_TEXTURE_GATHER   0x08"
.PP
This flag must be set in order to perform texture gather operations on a CUDA array. 
.SS "#define CUDA_VERSION   8000"
.PP
CUDA API version number 
.SS "#define MAX_PLANES   3"
.PP
Maximum number of planes per frame 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct CUarray_st* \fBCUarray\fP"
.PP
CUDA array 
.SS "typedef struct CUctx_st* \fBCUcontext\fP"
.PP
CUDA context 
.SS "typedef int \fBCUdevice\fP"
.PP
CUDA device 
.SS "typedef unsigned int \fBCUdeviceptr\fP"
.PP
CUDA device pointer CUdeviceptr is defined as an unsigned integer type whose size matches the size of a pointer on the target platform. 
.SS "typedef struct CUeglStreamConnection_st* \fBCUeglStreamConnection\fP"
.PP
CUDA EGLSream Connection 
.SS "typedef struct CUevent_st* \fBCUevent\fP"
.PP
CUDA event 
.SS "typedef struct CUfunc_st* \fBCUfunction\fP"
.PP
CUDA function 
.SS "typedef struct CUgraphicsResource_st* \fBCUgraphicsResource\fP"
.PP
CUDA graphics interop resource 
.SS "typedef struct CUmipmappedArray_st* \fBCUmipmappedArray\fP"
.PP
CUDA mipmapped array 
.SS "typedef struct CUmod_st* \fBCUmodule\fP"
.PP
CUDA module 
.SS "typedef size_t(CUDA_CB * \fBCUoccupancyB2DSize\fP)(int blockSize)"
.PP
Block size to per-block dynamic shared memory mapping for a certain kernel 
.PP
\fBParameters:\fP
.RS 4
\fIblockSize\fP Block size of the kernel.
.RE
.PP
\fBReturns:\fP
.RS 4
The dynamic shared memory needed by a block. 
.RE
.PP

.SS "typedef struct CUstream_st* \fBCUstream\fP"
.PP
CUDA stream 
.SS "typedef void(CUDA_CB * \fBCUstreamCallback\fP)(\fBCUstream\fP hStream, \fBCUresult\fP status, void *userData)"
.PP
CUDA stream callback 
.PP
\fBParameters:\fP
.RS 4
\fIhStream\fP The stream the callback was added to, as passed to \fBcuStreamAddCallback\fP. May be NULL. 
.br
\fIstatus\fP \fBCUDA_SUCCESS\fP or any persistent error on the stream. 
.br
\fIuserData\fP User parameter provided at registration. 
.RE
.PP

.SS "typedef unsigned long long \fBCUsurfObject\fP"
.PP
An opaque value that represents a CUDA surface object 
.SS "typedef struct CUsurfref_st* \fBCUsurfref\fP"
.PP
CUDA surface reference 
.SS "typedef unsigned long long \fBCUtexObject\fP"
.PP
An opaque value that represents a CUDA texture object 
.SS "typedef struct CUtexref_st* \fBCUtexref\fP"
.PP
CUDA texture reference 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBCUaddress_mode\fP"
.PP
Texture reference addressing modes 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_TR_ADDRESS_MODE_WRAP \fP\fP
Wrapping address mode 
.TP
\fB\fICU_TR_ADDRESS_MODE_CLAMP \fP\fP
Clamp to edge address mode 
.TP
\fB\fICU_TR_ADDRESS_MODE_MIRROR \fP\fP
Mirror address mode 
.TP
\fB\fICU_TR_ADDRESS_MODE_BORDER \fP\fP
Border address mode 
.SS "enum \fBCUarray_cubemap_face\fP"
.PP
Array indices for cube faces 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_CUBEMAP_FACE_POSITIVE_X \fP\fP
Positive X face of cubemap 
.TP
\fB\fICU_CUBEMAP_FACE_NEGATIVE_X \fP\fP
Negative X face of cubemap 
.TP
\fB\fICU_CUBEMAP_FACE_POSITIVE_Y \fP\fP
Positive Y face of cubemap 
.TP
\fB\fICU_CUBEMAP_FACE_NEGATIVE_Y \fP\fP
Negative Y face of cubemap 
.TP
\fB\fICU_CUBEMAP_FACE_POSITIVE_Z \fP\fP
Positive Z face of cubemap 
.TP
\fB\fICU_CUBEMAP_FACE_NEGATIVE_Z \fP\fP
Negative Z face of cubemap 
.SS "enum \fBCUarray_format\fP"
.PP
Array formats 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_AD_FORMAT_UNSIGNED_INT8 \fP\fP
Unsigned 8-bit integers 
.TP
\fB\fICU_AD_FORMAT_UNSIGNED_INT16 \fP\fP
Unsigned 16-bit integers 
.TP
\fB\fICU_AD_FORMAT_UNSIGNED_INT32 \fP\fP
Unsigned 32-bit integers 
.TP
\fB\fICU_AD_FORMAT_SIGNED_INT8 \fP\fP
Signed 8-bit integers 
.TP
\fB\fICU_AD_FORMAT_SIGNED_INT16 \fP\fP
Signed 16-bit integers 
.TP
\fB\fICU_AD_FORMAT_SIGNED_INT32 \fP\fP
Signed 32-bit integers 
.TP
\fB\fICU_AD_FORMAT_HALF \fP\fP
16-bit floating point 
.TP
\fB\fICU_AD_FORMAT_FLOAT \fP\fP
32-bit floating point 
.SS "enum \fBCUcomputemode\fP"
.PP
Compute Modes 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_COMPUTEMODE_DEFAULT \fP\fP
Default compute mode (Multiple contexts allowed per device) 
.TP
\fB\fICU_COMPUTEMODE_PROHIBITED \fP\fP
Compute-prohibited mode (No contexts can be created on this device at this time) 
.TP
\fB\fICU_COMPUTEMODE_EXCLUSIVE_PROCESS \fP\fP
Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time) 
.SS "enum \fBCUctx_flags\fP"
.PP
Context creation flags 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_CTX_SCHED_AUTO \fP\fP
Automatic scheduling 
.TP
\fB\fICU_CTX_SCHED_SPIN \fP\fP
Set spin as default scheduling 
.TP
\fB\fICU_CTX_SCHED_YIELD \fP\fP
Set yield as default scheduling 
.TP
\fB\fICU_CTX_SCHED_BLOCKING_SYNC \fP\fP
Set blocking synchronization as default scheduling 
.TP
\fB\fICU_CTX_BLOCKING_SYNC \fP\fP
Set blocking synchronization as default scheduling 
.PP
\fBDeprecated\fP
.RS 4
This flag was deprecated as of CUDA 4.0 and was replaced with \fBCU_CTX_SCHED_BLOCKING_SYNC\fP. 
.RE
.PP

.TP
\fB\fICU_CTX_MAP_HOST \fP\fP
Support mapped pinned allocations 
.TP
\fB\fICU_CTX_LMEM_RESIZE_TO_MAX \fP\fP
Keep local memory allocation after launch 
.SS "enum \fBCUdevice_attribute\fP"
.PP
Device properties 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK \fP\fP
Maximum number of threads per block 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X \fP\fP
Maximum block dimension X 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y \fP\fP
Maximum block dimension Y 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z \fP\fP
Maximum block dimension Z 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X \fP\fP
Maximum grid dimension X 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y \fP\fP
Maximum grid dimension Y 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z \fP\fP
Maximum grid dimension Z 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK \fP\fP
Maximum shared memory available per block in bytes 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK \fP\fP
Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY \fP\fP
Memory available on device for __constant__ variables in a CUDA C kernel in bytes 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_WARP_SIZE \fP\fP
Warp size in threads 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_PITCH \fP\fP
Maximum pitch in bytes allowed by memory copies 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK \fP\fP
Maximum number of 32-bit registers available per block 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK \fP\fP
Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_CLOCK_RATE \fP\fP
Typical clock frequency in kilohertz 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT \fP\fP
Alignment requirement for textures 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_GPU_OVERLAP \fP\fP
Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT. 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT \fP\fP
Number of multiprocessors on device 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT \fP\fP
Specifies whether there is a run time limit on kernels 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_INTEGRATED \fP\fP
Device is integrated with host memory 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY \fP\fP
Device can map host memory into CUDA address space 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_COMPUTE_MODE \fP\fP
Compute mode (See \fBCUcomputemode\fP for details) 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH \fP\fP
Maximum 1D texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH \fP\fP
Maximum 2D texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT \fP\fP
Maximum 2D texture height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH \fP\fP
Maximum 3D texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT \fP\fP
Maximum 3D texture height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH \fP\fP
Maximum 3D texture depth 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH \fP\fP
Maximum 2D layered texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT \fP\fP
Maximum 2D layered texture height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS \fP\fP
Maximum layers in a 2D layered texture 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH \fP\fP
Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT \fP\fP
Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES \fP\fP
Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT \fP\fP
Alignment requirement for surfaces 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS \fP\fP
Device can possibly execute multiple kernels concurrently 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_ECC_ENABLED \fP\fP
Device has ECC support enabled 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_PCI_BUS_ID \fP\fP
PCI bus ID of the device 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID \fP\fP
PCI device ID of the device 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_TCC_DRIVER \fP\fP
Device is using TCC driver model 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE \fP\fP
Peak memory clock frequency in kilohertz 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH \fP\fP
Global memory bus width in bits 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE \fP\fP
Size of L2 cache in bytes 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR \fP\fP
Maximum resident threads per multiprocessor 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT \fP\fP
Number of asynchronous engines 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING \fP\fP
Device shares a unified address space with the host 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH \fP\fP
Maximum 1D layered texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS \fP\fP
Maximum layers in a 1D layered texture 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER \fP\fP
Deprecated, do not use. 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH \fP\fP
Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT \fP\fP
Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE \fP\fP
Alternate maximum 3D texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE \fP\fP
Alternate maximum 3D texture height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE \fP\fP
Alternate maximum 3D texture depth 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID \fP\fP
PCI domain ID of the device 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT \fP\fP
Pitch alignment requirement for textures 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH \fP\fP
Maximum cubemap texture width/height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH \fP\fP
Maximum cubemap layered texture width/height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS \fP\fP
Maximum layers in a cubemap layered texture 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH \fP\fP
Maximum 1D surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH \fP\fP
Maximum 2D surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT \fP\fP
Maximum 2D surface height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH \fP\fP
Maximum 3D surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT \fP\fP
Maximum 3D surface height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH \fP\fP
Maximum 3D surface depth 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH \fP\fP
Maximum 1D layered surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS \fP\fP
Maximum layers in a 1D layered surface 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH \fP\fP
Maximum 2D layered surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT \fP\fP
Maximum 2D layered surface height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS \fP\fP
Maximum layers in a 2D layered surface 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH \fP\fP
Maximum cubemap surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH \fP\fP
Maximum cubemap layered surface width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS \fP\fP
Maximum layers in a cubemap layered surface 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH \fP\fP
Maximum 1D linear texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH \fP\fP
Maximum 2D linear texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT \fP\fP
Maximum 2D linear texture height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH \fP\fP
Maximum 2D linear texture pitch in bytes 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH \fP\fP
Maximum mipmapped 2D texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT \fP\fP
Maximum mipmapped 2D texture height 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR \fP\fP
Major compute capability version number 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR \fP\fP
Minor compute capability version number 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH \fP\fP
Maximum mipmapped 1D texture width 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED \fP\fP
Device supports stream priorities 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED \fP\fP
Device supports caching globals in L1 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED \fP\fP
Device supports caching locals in L1 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR \fP\fP
Maximum shared memory available per multiprocessor in bytes 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR \fP\fP
Maximum number of 32-bit registers available per multiprocessor 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MANAGED_MEMORY \fP\fP
Device can allocate managed memory on this system 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD \fP\fP
Device is on a multi-GPU board 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID \fP\fP
Unique id for a group of devices on the same multi-GPU board 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED \fP\fP
Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware) 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO \fP\fP
Ratio of single precision performance (in floating-point operations per second) to double precision performance 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS \fP\fP
Device supports coherently accessing pageable memory without calling cudaHostRegister on it 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS \fP\fP
Device can coherently access managed memory concurrently with the CPU 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED \fP\fP
Device supports compute preemption. 
.TP
\fB\fICU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM \fP\fP
Device can access host registered memory at the same virtual address as the CPU 
.SS "enum \fBCUdevice_P2PAttribute\fP"
.PP
P2P Attributes 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK \fP\fP
A relative value indicating the performance of the link between two devices 
.TP
\fB\fICU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED \fP\fP
P2P Access is enable 
.TP
\fB\fICU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED \fP\fP
Atomic operation over the link supported 
.SS "enum \fBCUeglColorFormat\fP"
.PP
CUDA EGL Color Format - The different planar and multiplanar formats currently supported for CUDA_EGL interops. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_EGL_COLOR_FORMAT_YUV420_PLANAR \fP\fP
Y, U, V in three surfaces, each in a separate surface, U/V width = 1/2 Y width, U/V height = 1/2 Y height. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR \fP\fP
Y, UV in two surfaces (UV as one surface), width, height ratio same as YUV420Planar. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_YUV422_PLANAR \fP\fP
Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V height = Y height. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR \fP\fP
Y, UV in two surfaces, width, height ratio same as YUV422Planar. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_RGB \fP\fP
R/G/B three channels in one surface with RGB byte ordering. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_BGR \fP\fP
R/G/B three channels in one surface with BGR byte ordering. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_ARGB \fP\fP
R/G/B/A four channels in one surface with ARGB byte ordering. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_RGBA \fP\fP
R/G/B/A four channels in one surface with RGBA byte ordering. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_L \fP\fP
single luminance channel in one surface. 
.TP
\fB\fICU_EGL_COLOR_FORMAT_R \fP\fP
single color channel in one surface. 
.SS "enum \fBCUeglFrameType\fP"
.PP
CUDA EglFrame type - array or pointer 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_EGL_FRAME_TYPE_ARRAY \fP\fP
Frame type CUDA array 
.TP
\fB\fICU_EGL_FRAME_TYPE_PITCH \fP\fP
Frame type pointer 
.SS "enum \fBCUeglResourceLocationFlags\fP"
.PP
Resource location flags- sysmem or vidmem If the producer is on sysmem and CU_EGL_RESOURCE_LOCATION_VIDMEM is set, it will involve additional copy of the resource from sysmem to vidmem. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_EGL_RESOURCE_LOCATION_SYSMEM \fP\fP
Resource location sysmem 
.TP
\fB\fICU_EGL_RESOURCE_LOCATION_VIDMEM \fP\fP
Resource location vidmem 
.SS "enum \fBCUevent_flags\fP"
.PP
Event creation flags 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_EVENT_DEFAULT \fP\fP
Default event flag 
.TP
\fB\fICU_EVENT_BLOCKING_SYNC \fP\fP
Event uses blocking synchronization 
.TP
\fB\fICU_EVENT_DISABLE_TIMING \fP\fP
Event will not record timing data 
.TP
\fB\fICU_EVENT_INTERPROCESS \fP\fP
Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must be set 
.SS "enum \fBCUfilter_mode\fP"
.PP
Texture reference filtering modes 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_TR_FILTER_MODE_POINT \fP\fP
Point filter mode 
.TP
\fB\fICU_TR_FILTER_MODE_LINEAR \fP\fP
Linear filter mode 
.SS "enum \fBCUfunc_cache\fP"
.PP
Function cache configurations 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_FUNC_CACHE_PREFER_NONE \fP\fP
no preference for shared memory or L1 (default) 
.TP
\fB\fICU_FUNC_CACHE_PREFER_SHARED \fP\fP
prefer larger shared memory and smaller L1 cache 
.TP
\fB\fICU_FUNC_CACHE_PREFER_L1 \fP\fP
prefer larger L1 cache and smaller shared memory 
.TP
\fB\fICU_FUNC_CACHE_PREFER_EQUAL \fP\fP
prefer equal sized L1 cache and shared memory 
.SS "enum \fBCUfunction_attribute\fP"
.PP
Function properties 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK \fP\fP
The maximum number of threads per block, beyond which a launch of the function would fail. This number depends on both the function and the device on which the function is currently loaded. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES \fP\fP
The size in bytes of statically-allocated shared memory required by this function. This does not include dynamically-allocated shared memory requested by the user at runtime. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES \fP\fP
The size in bytes of user-allocated constant memory required by this function. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES \fP\fP
The size in bytes of local memory used by each thread of this function. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_NUM_REGS \fP\fP
The number of registers used by each thread of this function. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_PTX_VERSION \fP\fP
The PTX virtual architecture version for which the function was compiled. This value is the major PTX version * 10 + the minor PTX version, so a PTX version 1.3 function would return the value 13. Note that this may return the undefined value of 0 for cubins compiled prior to CUDA 3.0. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_BINARY_VERSION \fP\fP
The binary architecture version for which the function was compiled. This value is the major binary version * 10 + the minor binary version, so a binary version 1.3 function would return the value 13. Note that this will return a value of 10 for legacy cubins that do not have a properly-encoded binary architecture version. 
.TP
\fB\fICU_FUNC_ATTRIBUTE_CACHE_MODE_CA \fP\fP
The attribute to indicate whether the function has been compiled with user specified option '-Xptxas --dlcm=ca' set . 
.SS "enum \fBCUgraphicsMapResourceFlags\fP"
.PP
Flags for mapping and unmapping interop resources 
.SS "enum \fBCUgraphicsRegisterFlags\fP"
.PP
Flags to register a graphics resource 
.SS "enum \fBCUipcMem_flags\fP"
.PP
CUDA Ipc Mem Flags 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS \fP\fP
Automatically enable peer access between remote devices as needed 
.SS "enum \fBCUjit_cacheMode\fP"
.PP
Caching modes for dlcm 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_JIT_CACHE_OPTION_NONE \fP\fP
Compile with no -dlcm flag specified 
.TP
\fB\fICU_JIT_CACHE_OPTION_CG \fP\fP
Compile with L1 cache disabled 
.TP
\fB\fICU_JIT_CACHE_OPTION_CA \fP\fP
Compile with L1 cache enabled 
.SS "enum \fBCUjit_fallback\fP"
.PP
Cubin matching fallback strategies 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_PREFER_PTX \fP\fP
Prefer to compile ptx if exact binary match not found 
.TP
\fB\fICU_PREFER_BINARY \fP\fP
Prefer to fall back to compatible binary code if exact match not found 
.SS "enum \fBCUjit_option\fP"
.PP
Online compiler and linker options 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_JIT_MAX_REGISTERS \fP\fP
Max number of registers that a thread may use.
.br
 Option type: unsigned int
.br
 Applies to: compiler only 
.TP
\fB\fICU_JIT_THREADS_PER_BLOCK \fP\fP
IN: Specifies minimum number of threads per block to target compilation for
.br
 OUT: Returns the number of threads the compiler actually targeted. This restricts the resource utilization fo the compiler (e.g. max registers) such that a block with the given number of threads should be able to launch based on register limitations. Note, this option does not currently take into account any other resource limitations, such as shared memory utilization.
.br
 Cannot be combined with \fBCU_JIT_TARGET\fP.
.br
 Option type: unsigned int
.br
 Applies to: compiler only 
.TP
\fB\fICU_JIT_WALL_TIME \fP\fP
Overwrites the option value with the total wall clock time, in milliseconds, spent in the compiler and linker
.br
 Option type: float
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_INFO_LOG_BUFFER \fP\fP
Pointer to a buffer in which to print any log messages that are informational in nature (the buffer size is specified via option \fBCU_JIT_INFO_LOG_BUFFER_SIZE_BYTES\fP)
.br
 Option type: char *
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_INFO_LOG_BUFFER_SIZE_BYTES \fP\fP
IN: Log buffer size in bytes. Log messages will be capped at this size (including null terminator)
.br
 OUT: Amount of log buffer filled with messages
.br
 Option type: unsigned int
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_ERROR_LOG_BUFFER \fP\fP
Pointer to a buffer in which to print any log messages that reflect errors (the buffer size is specified via option \fBCU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES\fP)
.br
 Option type: char *
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES \fP\fP
IN: Log buffer size in bytes. Log messages will be capped at this size (including null terminator)
.br
 OUT: Amount of log buffer filled with messages
.br
 Option type: unsigned int
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_OPTIMIZATION_LEVEL \fP\fP
Level of optimizations to apply to generated code (0 - 4), with 4 being the default and highest level of optimizations.
.br
 Option type: unsigned int
.br
 Applies to: compiler only 
.TP
\fB\fICU_JIT_TARGET_FROM_CUCONTEXT \fP\fP
No option value required. Determines the target based on the current attached context (default)
.br
 Option type: No option value needed
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_TARGET \fP\fP
Target is chosen based on supplied \fBCUjit_target\fP. Cannot be combined with \fBCU_JIT_THREADS_PER_BLOCK\fP.
.br
 Option type: unsigned int for enumerated type \fBCUjit_target\fP
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_FALLBACK_STRATEGY \fP\fP
Specifies choice of fallback strategy if matching cubin is not found. Choice is based on supplied \fBCUjit_fallback\fP. This option cannot be used with cuLink* APIs as the linker requires exact matches.
.br
 Option type: unsigned int for enumerated type \fBCUjit_fallback\fP
.br
 Applies to: compiler only 
.TP
\fB\fICU_JIT_GENERATE_DEBUG_INFO \fP\fP
Specifies whether to create debug information in output (-g) (0: false, default)
.br
 Option type: int
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_LOG_VERBOSE \fP\fP
Generate verbose log messages (0: false, default)
.br
 Option type: int
.br
 Applies to: compiler and linker 
.TP
\fB\fICU_JIT_GENERATE_LINE_INFO \fP\fP
Generate line number information (-lineinfo) (0: false, default)
.br
 Option type: int
.br
 Applies to: compiler only 
.TP
\fB\fICU_JIT_CACHE_MODE \fP\fP
Specifies whether to enable caching explicitly (-dlcm) 
.br
 Choice is based on supplied CUjit_cacheMode_enum.
.br
 Option type: unsigned int for enumerated type CUjit_cacheMode_enum
.br
 Applies to: compiler only 
.TP
\fB\fICU_JIT_NEW_SM3X_OPT \fP\fP
The below jit options are used for internal purposes only, in this version of CUDA 
.SS "enum \fBCUjit_target\fP"
.PP
Online compilation targets 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_TARGET_COMPUTE_10 \fP\fP
Compute device class 1.0 
.TP
\fB\fICU_TARGET_COMPUTE_11 \fP\fP
Compute device class 1.1 
.TP
\fB\fICU_TARGET_COMPUTE_12 \fP\fP
Compute device class 1.2 
.TP
\fB\fICU_TARGET_COMPUTE_13 \fP\fP
Compute device class 1.3 
.TP
\fB\fICU_TARGET_COMPUTE_20 \fP\fP
Compute device class 2.0 
.TP
\fB\fICU_TARGET_COMPUTE_21 \fP\fP
Compute device class 2.1 
.TP
\fB\fICU_TARGET_COMPUTE_30 \fP\fP
Compute device class 3.0 
.TP
\fB\fICU_TARGET_COMPUTE_32 \fP\fP
Compute device class 3.2 
.TP
\fB\fICU_TARGET_COMPUTE_35 \fP\fP
Compute device class 3.5 
.TP
\fB\fICU_TARGET_COMPUTE_37 \fP\fP
Compute device class 3.7 
.TP
\fB\fICU_TARGET_COMPUTE_50 \fP\fP
Compute device class 5.0 
.TP
\fB\fICU_TARGET_COMPUTE_52 \fP\fP
Compute device class 5.2 
.TP
\fB\fICU_TARGET_COMPUTE_53 \fP\fP
Compute device class 5.3 
.TP
\fB\fICU_TARGET_COMPUTE_60 \fP\fP
Compute device class 6.0. This must be removed for CUDA 7.0 toolkit. See bug 1518217. 
.TP
\fB\fICU_TARGET_COMPUTE_61 \fP\fP
Compute device class 6.1. This must be removed for CUDA 7.0 toolkit. 
.TP
\fB\fICU_TARGET_COMPUTE_62 \fP\fP
Compute device class 6.2. This must be removed for CUDA 7.0 toolkit. 
.SS "enum \fBCUjitInputType\fP"
.PP
Device code formats 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_JIT_INPUT_CUBIN \fP\fP
Compiled device-class-specific device code
.br
 Applicable options: none 
.TP
\fB\fICU_JIT_INPUT_PTX \fP\fP
PTX source code
.br
 Applicable options: PTX compiler options 
.TP
\fB\fICU_JIT_INPUT_FATBINARY \fP\fP
Bundle of multiple cubins and/or PTX of some device code
.br
 Applicable options: PTX compiler options, \fBCU_JIT_FALLBACK_STRATEGY\fP 
.TP
\fB\fICU_JIT_INPUT_OBJECT \fP\fP
Host object with embedded device code
.br
 Applicable options: PTX compiler options, \fBCU_JIT_FALLBACK_STRATEGY\fP 
.TP
\fB\fICU_JIT_INPUT_LIBRARY \fP\fP
Archive of host objects with embedded device code
.br
 Applicable options: PTX compiler options, \fBCU_JIT_FALLBACK_STRATEGY\fP 
.SS "enum \fBCUlimit\fP"
.PP
Limits 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_LIMIT_STACK_SIZE \fP\fP
GPU thread stack size 
.TP
\fB\fICU_LIMIT_PRINTF_FIFO_SIZE \fP\fP
GPU printf FIFO size 
.TP
\fB\fICU_LIMIT_MALLOC_HEAP_SIZE \fP\fP
GPU malloc heap size 
.TP
\fB\fICU_LIMIT_DEV_RUNTIME_SYNC_DEPTH \fP\fP
GPU device runtime launch synchronize depth 
.TP
\fB\fICU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT \fP\fP
GPU device runtime pending launch count 
.SS "enum \fBCUmem_advise\fP"
.PP
Memory advise values 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_MEM_ADVISE_SET_READ_MOSTLY \fP\fP
Data will mostly be read and only occassionally be written to 
.TP
\fB\fICU_MEM_ADVISE_UNSET_READ_MOSTLY \fP\fP
Undo the effect of \fBCU_MEM_ADVISE_SET_READ_MOSTLY\fP 
.TP
\fB\fICU_MEM_ADVISE_SET_PREFERRED_LOCATION \fP\fP
Set the preferred location for the data as the specified device 
.TP
\fB\fICU_MEM_ADVISE_UNSET_PREFERRED_LOCATION \fP\fP
Clear the preferred location for the data 
.TP
\fB\fICU_MEM_ADVISE_SET_ACCESSED_BY \fP\fP
Data will be accessed by the specified device, so prevent page faults as much as possible 
.TP
\fB\fICU_MEM_ADVISE_UNSET_ACCESSED_BY \fP\fP
Let the Unified Memory subsystem decide on the page faulting policy for the specified device 
.SS "enum \fBCUmem_range_attribute\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY \fP\fP
Whether the range will mostly be read and only occassionally be written to 
.TP
\fB\fICU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION \fP\fP
The preferred location of the range 
.TP
\fB\fICU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY \fP\fP
Memory range has \fBCU_MEM_ADVISE_SET_ACCESSED_BY\fP set for specified device 
.TP
\fB\fICU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION \fP\fP
The last location to which the range was prefetched 
.SS "enum \fBCUmemAttach_flags\fP"
.PP
CUDA Mem Attach Flags 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_MEM_ATTACH_GLOBAL \fP\fP
Memory can be accessed by any stream on any device 
.TP
\fB\fICU_MEM_ATTACH_HOST \fP\fP
Memory cannot be accessed by any stream on any device 
.TP
\fB\fICU_MEM_ATTACH_SINGLE \fP\fP
Memory can only be accessed by a single stream on the associated device 
.SS "enum \fBCUmemorytype\fP"
.PP
Memory types 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_MEMORYTYPE_HOST \fP\fP
Host memory 
.TP
\fB\fICU_MEMORYTYPE_DEVICE \fP\fP
Device memory 
.TP
\fB\fICU_MEMORYTYPE_ARRAY \fP\fP
Array memory 
.TP
\fB\fICU_MEMORYTYPE_UNIFIED \fP\fP
Unified device or host memory 
.SS "enum \fBCUoccupancy_flags\fP"
.PP
Occupancy calculator flag 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_OCCUPANCY_DEFAULT \fP\fP
Default behavior 
.TP
\fB\fICU_OCCUPANCY_DISABLE_CACHING_OVERRIDE \fP\fP
Assume global caching is enabled and cannot be automatically turned off 
.SS "enum \fBCUpointer_attribute\fP"
.PP
Pointer information 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_POINTER_ATTRIBUTE_CONTEXT \fP\fP
The \fBCUcontext\fP on which a pointer was allocated or registered 
.TP
\fB\fICU_POINTER_ATTRIBUTE_MEMORY_TYPE \fP\fP
The \fBCUmemorytype\fP describing the physical location of a pointer 
.TP
\fB\fICU_POINTER_ATTRIBUTE_DEVICE_POINTER \fP\fP
The address at which a pointer's memory may be accessed on the device 
.TP
\fB\fICU_POINTER_ATTRIBUTE_HOST_POINTER \fP\fP
The address at which a pointer's memory may be accessed on the host 
.TP
\fB\fICU_POINTER_ATTRIBUTE_P2P_TOKENS \fP\fP
A pair of tokens for use with the nv-p2p.h Linux kernel interface 
.TP
\fB\fICU_POINTER_ATTRIBUTE_SYNC_MEMOPS \fP\fP
Synchronize every synchronous memory operation initiated on this region 
.TP
\fB\fICU_POINTER_ATTRIBUTE_BUFFER_ID \fP\fP
A process-wide unique ID for an allocated memory region 
.TP
\fB\fICU_POINTER_ATTRIBUTE_IS_MANAGED \fP\fP
Indicates if the pointer points to managed memory 
.SS "enum \fBCUresourcetype\fP"
.PP
Resource types 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_RESOURCE_TYPE_ARRAY \fP\fP
Array resoure 
.TP
\fB\fICU_RESOURCE_TYPE_MIPMAPPED_ARRAY \fP\fP
Mipmapped array resource 
.TP
\fB\fICU_RESOURCE_TYPE_LINEAR \fP\fP
Linear resource 
.TP
\fB\fICU_RESOURCE_TYPE_PITCH2D \fP\fP
Pitch 2D resource 
.SS "enum \fBCUresourceViewFormat\fP"
.PP
Resource view format 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_RES_VIEW_FORMAT_NONE \fP\fP
No resource view format (use underlying resource format) 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_1X8 \fP\fP
1 channel unsigned 8-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_2X8 \fP\fP
2 channel unsigned 8-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_4X8 \fP\fP
4 channel unsigned 8-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_1X8 \fP\fP
1 channel signed 8-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_2X8 \fP\fP
2 channel signed 8-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_4X8 \fP\fP
4 channel signed 8-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_1X16 \fP\fP
1 channel unsigned 16-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_2X16 \fP\fP
2 channel unsigned 16-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_4X16 \fP\fP
4 channel unsigned 16-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_1X16 \fP\fP
1 channel signed 16-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_2X16 \fP\fP
2 channel signed 16-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_4X16 \fP\fP
4 channel signed 16-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_1X32 \fP\fP
1 channel unsigned 32-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_2X32 \fP\fP
2 channel unsigned 32-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_UINT_4X32 \fP\fP
4 channel unsigned 32-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_1X32 \fP\fP
1 channel signed 32-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_2X32 \fP\fP
2 channel signed 32-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_SINT_4X32 \fP\fP
4 channel signed 32-bit integers 
.TP
\fB\fICU_RES_VIEW_FORMAT_FLOAT_1X16 \fP\fP
1 channel 16-bit floating point 
.TP
\fB\fICU_RES_VIEW_FORMAT_FLOAT_2X16 \fP\fP
2 channel 16-bit floating point 
.TP
\fB\fICU_RES_VIEW_FORMAT_FLOAT_4X16 \fP\fP
4 channel 16-bit floating point 
.TP
\fB\fICU_RES_VIEW_FORMAT_FLOAT_1X32 \fP\fP
1 channel 32-bit floating point 
.TP
\fB\fICU_RES_VIEW_FORMAT_FLOAT_2X32 \fP\fP
2 channel 32-bit floating point 
.TP
\fB\fICU_RES_VIEW_FORMAT_FLOAT_4X32 \fP\fP
4 channel 32-bit floating point 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC1 \fP\fP
Block compressed 1 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC2 \fP\fP
Block compressed 2 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC3 \fP\fP
Block compressed 3 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC4 \fP\fP
Block compressed 4 unsigned 
.TP
\fB\fICU_RES_VIEW_FORMAT_SIGNED_BC4 \fP\fP
Block compressed 4 signed 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC5 \fP\fP
Block compressed 5 unsigned 
.TP
\fB\fICU_RES_VIEW_FORMAT_SIGNED_BC5 \fP\fP
Block compressed 5 signed 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC6H \fP\fP
Block compressed 6 unsigned half-float 
.TP
\fB\fICU_RES_VIEW_FORMAT_SIGNED_BC6H \fP\fP
Block compressed 6 signed half-float 
.TP
\fB\fICU_RES_VIEW_FORMAT_UNSIGNED_BC7 \fP\fP
Block compressed 7 
.SS "enum \fBCUresult\fP"
.PP
Error codes 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICUDA_SUCCESS \fP\fP
The API call returned with no errors. In the case of query calls, this can also mean that the operation being queried is complete (see \fBcuEventQuery()\fP and \fBcuStreamQuery()\fP). 
.TP
\fB\fICUDA_ERROR_INVALID_VALUE \fP\fP
This indicates that one or more of the parameters passed to the API call is not within an acceptable range of values. 
.TP
\fB\fICUDA_ERROR_OUT_OF_MEMORY \fP\fP
The API call failed because it was unable to allocate enough memory to perform the requested operation. 
.TP
\fB\fICUDA_ERROR_NOT_INITIALIZED \fP\fP
This indicates that the CUDA driver has not been initialized with \fBcuInit()\fP or that initialization has failed. 
.TP
\fB\fICUDA_ERROR_DEINITIALIZED \fP\fP
This indicates that the CUDA driver is in the process of shutting down. 
.TP
\fB\fICUDA_ERROR_PROFILER_DISABLED \fP\fP
This indicates profiler is not initialized for this run. This can happen when the application is running with external profiling tools like visual profiler. 
.TP
\fB\fICUDA_ERROR_PROFILER_NOT_INITIALIZED \fP\fP
\fBDeprecated\fP
.RS 4
This error return is deprecated as of CUDA 5.0. It is no longer an error to attempt to enable/disable the profiling via \fBcuProfilerStart\fP or \fBcuProfilerStop\fP without initialization. 
.RE
.PP

.TP
\fB\fICUDA_ERROR_PROFILER_ALREADY_STARTED \fP\fP
\fBDeprecated\fP
.RS 4
This error return is deprecated as of CUDA 5.0. It is no longer an error to call \fBcuProfilerStart()\fP when profiling is already enabled. 
.RE
.PP

.TP
\fB\fICUDA_ERROR_PROFILER_ALREADY_STOPPED \fP\fP
\fBDeprecated\fP
.RS 4
This error return is deprecated as of CUDA 5.0. It is no longer an error to call \fBcuProfilerStop()\fP when profiling is already disabled. 
.RE
.PP

.TP
\fB\fICUDA_ERROR_NO_DEVICE \fP\fP
This indicates that no CUDA-capable devices were detected by the installed CUDA driver. 
.TP
\fB\fICUDA_ERROR_INVALID_DEVICE \fP\fP
This indicates that the device ordinal supplied by the user does not correspond to a valid CUDA device. 
.TP
\fB\fICUDA_ERROR_INVALID_IMAGE \fP\fP
This indicates that the device kernel image is invalid. This can also indicate an invalid CUDA module. 
.TP
\fB\fICUDA_ERROR_INVALID_CONTEXT \fP\fP
This most frequently indicates that there is no context bound to the current thread. This can also be returned if the context passed to an API call is not a valid handle (such as a context that has had \fBcuCtxDestroy()\fP invoked on it). This can also be returned if a user mixes different API versions (i.e. 3010 context with 3020 API calls). See \fBcuCtxGetApiVersion()\fP for more details. 
.TP
\fB\fICUDA_ERROR_CONTEXT_ALREADY_CURRENT \fP\fP
This indicated that the context being supplied as a parameter to the API call was already the active context. 
.PP
\fBDeprecated\fP
.RS 4
This error return is deprecated as of CUDA 3.2. It is no longer an error to attempt to push the active context via \fBcuCtxPushCurrent()\fP. 
.RE
.PP

.TP
\fB\fICUDA_ERROR_MAP_FAILED \fP\fP
This indicates that a map or register operation has failed. 
.TP
\fB\fICUDA_ERROR_UNMAP_FAILED \fP\fP
This indicates that an unmap or unregister operation has failed. 
.TP
\fB\fICUDA_ERROR_ARRAY_IS_MAPPED \fP\fP
This indicates that the specified array is currently mapped and thus cannot be destroyed. 
.TP
\fB\fICUDA_ERROR_ALREADY_MAPPED \fP\fP
This indicates that the resource is already mapped. 
.TP
\fB\fICUDA_ERROR_NO_BINARY_FOR_GPU \fP\fP
This indicates that there is no kernel image available that is suitable for the device. This can occur when a user specifies code generation options for a particular CUDA source file that do not include the corresponding device configuration. 
.TP
\fB\fICUDA_ERROR_ALREADY_ACQUIRED \fP\fP
This indicates that a resource has already been acquired. 
.TP
\fB\fICUDA_ERROR_NOT_MAPPED \fP\fP
This indicates that a resource is not mapped. 
.TP
\fB\fICUDA_ERROR_NOT_MAPPED_AS_ARRAY \fP\fP
This indicates that a mapped resource is not available for access as an array. 
.TP
\fB\fICUDA_ERROR_NOT_MAPPED_AS_POINTER \fP\fP
This indicates that a mapped resource is not available for access as a pointer. 
.TP
\fB\fICUDA_ERROR_ECC_UNCORRECTABLE \fP\fP
This indicates that an uncorrectable ECC error was detected during execution. 
.TP
\fB\fICUDA_ERROR_UNSUPPORTED_LIMIT \fP\fP
This indicates that the \fBCUlimit\fP passed to the API call is not supported by the active device. 
.TP
\fB\fICUDA_ERROR_CONTEXT_ALREADY_IN_USE \fP\fP
This indicates that the \fBCUcontext\fP passed to the API call can only be bound to a single CPU thread at a time but is already bound to a CPU thread. 
.TP
\fB\fICUDA_ERROR_PEER_ACCESS_UNSUPPORTED \fP\fP
This indicates that peer access is not supported across the given devices. 
.TP
\fB\fICUDA_ERROR_INVALID_PTX \fP\fP
This indicates that a PTX JIT compilation failed. 
.TP
\fB\fICUDA_ERROR_INVALID_GRAPHICS_CONTEXT \fP\fP
This indicates an error with OpenGL or DirectX context. 
.TP
\fB\fICUDA_ERROR_NVLINK_UNCORRECTABLE \fP\fP
This indicates that an uncorrectable NVLink error was detected during the execution. 
.TP
\fB\fICUDA_ERROR_INVALID_SOURCE \fP\fP
This indicates that the device kernel source is invalid. 
.TP
\fB\fICUDA_ERROR_FILE_NOT_FOUND \fP\fP
This indicates that the file specified was not found. 
.TP
\fB\fICUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND \fP\fP
This indicates that a link to a shared object failed to resolve. 
.TP
\fB\fICUDA_ERROR_SHARED_OBJECT_INIT_FAILED \fP\fP
This indicates that initialization of a shared object failed. 
.TP
\fB\fICUDA_ERROR_OPERATING_SYSTEM \fP\fP
This indicates that an OS call failed. 
.TP
\fB\fICUDA_ERROR_INVALID_HANDLE \fP\fP
This indicates that a resource handle passed to the API call was not valid. Resource handles are opaque types like \fBCUstream\fP and \fBCUevent\fP. 
.TP
\fB\fICUDA_ERROR_NOT_FOUND \fP\fP
This indicates that a named symbol was not found. Examples of symbols are global/constant variable names, texture names, and surface names. 
.TP
\fB\fICUDA_ERROR_NOT_READY \fP\fP
This indicates that asynchronous operations issued previously have not completed yet. This result is not actually an error, but must be indicated differently than \fBCUDA_SUCCESS\fP (which indicates completion). Calls that may return this value include \fBcuEventQuery()\fP and \fBcuStreamQuery()\fP. 
.TP
\fB\fICUDA_ERROR_ILLEGAL_ADDRESS \fP\fP
While executing a kernel, the device encountered a load or store instruction on an invalid memory address. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_LAUNCH_OUT_OF_RESOURCES \fP\fP
This indicates that a launch did not occur because it did not have appropriate resources. This error usually indicates that the user has attempted to pass too many arguments to the device kernel, or the kernel launch specifies too many threads for the kernel's register count. Passing arguments of the wrong size (i.e. a 64-bit pointer when a 32-bit int is expected) is equivalent to passing too many arguments and can also result in this error. 
.TP
\fB\fICUDA_ERROR_LAUNCH_TIMEOUT \fP\fP
This indicates that the device kernel took too long to execute. This can only occur if timeouts are enabled - see the device attribute \fBCU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT\fP for more information. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING \fP\fP
This error indicates a kernel launch that uses an incompatible texturing mode. 
.TP
\fB\fICUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED \fP\fP
This error indicates that a call to \fBcuCtxEnablePeerAccess()\fP is trying to re-enable peer access to a context which has already had peer access to it enabled. 
.TP
\fB\fICUDA_ERROR_PEER_ACCESS_NOT_ENABLED \fP\fP
This error indicates that \fBcuCtxDisablePeerAccess()\fP is trying to disable peer access which has not been enabled yet via \fBcuCtxEnablePeerAccess()\fP. 
.TP
\fB\fICUDA_ERROR_PRIMARY_CONTEXT_ACTIVE \fP\fP
This error indicates that the primary context for the specified device has already been initialized. 
.TP
\fB\fICUDA_ERROR_CONTEXT_IS_DESTROYED \fP\fP
This error indicates that the context current to the calling thread has been destroyed using \fBcuCtxDestroy\fP, or is a primary context which has not yet been initialized. 
.TP
\fB\fICUDA_ERROR_ASSERT \fP\fP
A device-side assert triggered during kernel execution. The context cannot be used anymore, and must be destroyed. All existing device memory allocations from this context are invalid and must be reconstructed if the program is to continue using CUDA. 
.TP
\fB\fICUDA_ERROR_TOO_MANY_PEERS \fP\fP
This error indicates that the hardware resources required to enable peer access have been exhausted for one or more of the devices passed to \fBcuCtxEnablePeerAccess()\fP. 
.TP
\fB\fICUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED \fP\fP
This error indicates that the memory range passed to \fBcuMemHostRegister()\fP has already been registered. 
.TP
\fB\fICUDA_ERROR_HOST_MEMORY_NOT_REGISTERED \fP\fP
This error indicates that the pointer passed to \fBcuMemHostUnregister()\fP does not correspond to any currently registered memory region. 
.TP
\fB\fICUDA_ERROR_HARDWARE_STACK_ERROR \fP\fP
While executing a kernel, the device encountered a stack error. This can be due to stack corruption or exceeding the stack size limit. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_ILLEGAL_INSTRUCTION \fP\fP
While executing a kernel, the device encountered an illegal instruction. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_MISALIGNED_ADDRESS \fP\fP
While executing a kernel, the device encountered a load or store instruction on a memory address which is not aligned. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_INVALID_ADDRESS_SPACE \fP\fP
While executing a kernel, the device encountered an instruction which can only operate on memory locations in certain address spaces (global, shared, or local), but was supplied a memory address not belonging to an allowed address space. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_INVALID_PC \fP\fP
While executing a kernel, the device program counter wrapped its address space. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_LAUNCH_FAILED \fP\fP
An exception occurred on the device while executing a kernel. Common causes include dereferencing an invalid device pointer and accessing out of bounds shared memory. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched. 
.TP
\fB\fICUDA_ERROR_NOT_PERMITTED \fP\fP
This error indicates that the attempted operation is not permitted. 
.TP
\fB\fICUDA_ERROR_NOT_SUPPORTED \fP\fP
This error indicates that the attempted operation is not supported on the current system or device. 
.TP
\fB\fICUDA_ERROR_UNKNOWN \fP\fP
This indicates that an unknown internal error has occurred. 
.SS "enum \fBCUsharedconfig\fP"
.PP
Shared memory configurations 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE \fP\fP
set default shared memory bank size 
.TP
\fB\fICU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE \fP\fP
set shared memory bank width to four bytes 
.TP
\fB\fICU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE \fP\fP
set shared memory bank width to eight bytes 
.SS "enum \fBCUstream_flags\fP"
.PP
Stream creation flags 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_STREAM_DEFAULT \fP\fP
Default stream flag 
.TP
\fB\fICU_STREAM_NON_BLOCKING \fP\fP
Stream does not synchronize with stream 0 (the NULL stream) 
.SS "enum \fBCUstreamBatchMemOpType\fP"
.PP
Operations for \fBcuStreamBatchMemOp\fP 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_STREAM_MEM_OP_WAIT_VALUE_32 \fP\fP
Represents a \fBcuStreamWaitValue32\fP operation 
.TP
\fB\fICU_STREAM_MEM_OP_WRITE_VALUE_32 \fP\fP
Represents a \fBcuStreamWriteValue32\fP operation 
.TP
\fB\fICU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES \fP\fP
This has the same effect as \fBCU_STREAM_WAIT_VALUE_FLUSH\fP, but as a standalone operation. 
.SS "enum \fBCUstreamWaitValue_flags\fP"
.PP
Flags for \fBcuStreamWaitValue32\fP 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_STREAM_WAIT_VALUE_GEQ \fP\fP
Wait until (int32_t)(*addr - value) >= 0. Note this is a cyclic comparison which ignores wraparound. (Default behavior.) 
.TP
\fB\fICU_STREAM_WAIT_VALUE_EQ \fP\fP
Wait until *addr == value. 
.TP
\fB\fICU_STREAM_WAIT_VALUE_AND \fP\fP
Wait until (*addr & value) != 0. 
.TP
\fB\fICU_STREAM_WAIT_VALUE_FLUSH \fP\fP
Follow the wait operation with a flush of outstanding remote writes. This means that, if a remote write operation is guaranteed to have reached the device before the wait can be satisfied, that write is guaranteed to be visible to downstream device work. The device is permitted to reorder remote writes internally. For example, this flag would be required if two remote writes arrive in a defined order, the wait is satisfied by the second write, and downstream work needs to observe the first write. 
.SS "enum \fBCUstreamWriteValue_flags\fP"
.PP
Flags for \fBcuStreamWriteValue32\fP 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICU_STREAM_WRITE_VALUE_DEFAULT \fP\fP
Default behavior 
.TP
\fB\fICU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER \fP\fP
Permits the write to be reordered with writes which were issued before it, as a performance optimization. Normally, \fBcuStreamWriteValue32\fP will provide a memory fence before the write, which has similar semantics to __threadfence_system() but is scoped to the stream rather than a CUDA thread. 
.SH "Author"
.PP 
Generated automatically by Doxygen from the source code.
