.TH "cuda.h" 3 "12 Jan 2017" "Version 6.0" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cuda.h \- Header file for the CUDA Toolkit application programming interface.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBCUDA_ARRAY3D_DESCRIPTOR\fP"
.br
.ti -1c
.RI "struct \fBCUDA_ARRAY_DESCRIPTOR\fP"
.br
.ti -1c
.RI "struct \fBCUDA_MEMCPY2D\fP"
.br
.ti -1c
.RI "struct \fBCUDA_MEMCPY3D\fP"
.br
.ti -1c
.RI "struct \fBCUDA_MEMCPY3D_PEER\fP"
.br
.ti -1c
.RI "struct \fBCUDA_POINTER_ATTRIBUTE_P2P_TOKENS\fP"
.br
.ti -1c
.RI "struct \fBCUDA_RESOURCE_DESC\fP"
.br
.ti -1c
.RI "struct \fBCUDA_RESOURCE_VIEW_DESC\fP"
.br
.ti -1c
.RI "struct \fBCUDA_TEXTURE_DESC\fP"
.br
.ti -1c
.RI "struct \fBCUdevprop\fP"
.br
.ti -1c
.RI "struct \fBCUipcEventHandle\fP"
.br
.ti -1c
.RI "struct \fBCUipcMemHandle\fP"
.br
.ti -1c
.RI "union \fBCUstreamBatchMemOpParams\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fB__CUDA_API_VERSION\fP   8000"
.br
.ti -1c
.RI "#define \fBCU_DEVICE_CPU\fP   ((\fBCUdevice\fP)-1)"
.br
.ti -1c
.RI "#define \fBCU_DEVICE_INVALID\fP   ((\fBCUdevice\fP)-2)"
.br
.ti -1c
.RI "#define \fBCU_IPC_HANDLE_SIZE\fP   64"
.br
.ti -1c
.RI "#define \fBCU_LAUNCH_PARAM_BUFFER_POINTER\fP   ((void*)0x01)"
.br
.ti -1c
.RI "#define \fBCU_LAUNCH_PARAM_BUFFER_SIZE\fP   ((void*)0x02)"
.br
.ti -1c
.RI "#define \fBCU_LAUNCH_PARAM_END\fP   ((void*)0x00)"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTALLOC_DEVICEMAP\fP   0x02"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTALLOC_PORTABLE\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTALLOC_WRITECOMBINED\fP   0x04"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTREGISTER_DEVICEMAP\fP   0x02"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTREGISTER_IOMEMORY\fP   0x04"
.br
.ti -1c
.RI "#define \fBCU_MEMHOSTREGISTER_PORTABLE\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_PARAM_TR_DEFAULT\fP   -1"
.br
.ti -1c
.RI "#define \fBCU_STREAM_LEGACY\fP   ((\fBCUstream\fP)0x1)"
.br
.ti -1c
.RI "#define \fBCU_STREAM_PER_THREAD\fP   ((\fBCUstream\fP)0x2)"
.br
.ti -1c
.RI "#define \fBCU_TRSA_OVERRIDE_FORMAT\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_TRSF_NORMALIZED_COORDINATES\fP   0x02"
.br
.ti -1c
.RI "#define \fBCU_TRSF_READ_AS_INTEGER\fP   0x01"
.br
.ti -1c
.RI "#define \fBCU_TRSF_SRGB\fP   0x10"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_2DARRAY\fP   0x01"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_CUBEMAP\fP   0x04"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_DEPTH_TEXTURE\fP   0x10"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_LAYERED\fP   0x01"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_SURFACE_LDST\fP   0x02"
.br
.ti -1c
.RI "#define \fBCUDA_ARRAY3D_TEXTURE_GATHER\fP   0x08"
.br
.ti -1c
.RI "#define \fBCUDA_VERSION\fP   8000"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct CUarray_st * \fBCUarray\fP"
.br
.ti -1c
.RI "typedef struct CUctx_st * \fBCUcontext\fP"
.br
.ti -1c
.RI "typedef int \fBCUdevice\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBCUdeviceptr\fP"
.br
.ti -1c
.RI "typedef struct CUevent_st * \fBCUevent\fP"
.br
.ti -1c
.RI "typedef struct CUfunc_st * \fBCUfunction\fP"
.br
.ti -1c
.RI "typedef struct CUgraphicsResource_st * \fBCUgraphicsResource\fP"
.br
.ti -1c
.RI "typedef struct CUmipmappedArray_st * \fBCUmipmappedArray\fP"
.br
.ti -1c
.RI "typedef struct CUmod_st * \fBCUmodule\fP"
.br
.ti -1c
.RI "typedef size_t(CUDA_CB * \fBCUoccupancyB2DSize\fP )(int blockSize)"
.br
.ti -1c
.RI "typedef struct CUstream_st * \fBCUstream\fP"
.br
.ti -1c
.RI "typedef void(CUDA_CB * \fBCUstreamCallback\fP )(\fBCUstream\fP hStream, \fBCUresult\fP status, void *userData)"
.br
.ti -1c
.RI "typedef unsigned long long \fBCUsurfObject\fP"
.br
.ti -1c
.RI "typedef struct CUsurfref_st * \fBCUsurfref\fP"
.br
.ti -1c
.RI "typedef unsigned long long \fBCUtexObject\fP"
.br
.ti -1c
.RI "typedef struct CUtexref_st * \fBCUtexref\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBCUaddress_mode\fP { \fBCU_TR_ADDRESS_MODE_WRAP\fP =  0, \fBCU_TR_ADDRESS_MODE_CLAMP\fP =  1, \fBCU_TR_ADDRESS_MODE_MIRROR\fP =  2, \fBCU_TR_ADDRESS_MODE_BORDER\fP =  3 }"
.br
.ti -1c
.RI "enum \fBCUarray_cubemap_face\fP { \fBCU_CUBEMAP_FACE_POSITIVE_X\fP =  0x00, \fBCU_CUBEMAP_FACE_NEGATIVE_X\fP =  0x01, \fBCU_CUBEMAP_FACE_POSITIVE_Y\fP =  0x02, \fBCU_CUBEMAP_FACE_NEGATIVE_Y\fP =  0x03, \fBCU_CUBEMAP_FACE_POSITIVE_Z\fP =  0x04, \fBCU_CUBEMAP_FACE_NEGATIVE_Z\fP =  0x05 }"
.br
.ti -1c
.RI "enum \fBCUarray_format\fP { \fBCU_AD_FORMAT_UNSIGNED_INT8\fP =  0x01, \fBCU_AD_FORMAT_UNSIGNED_INT16\fP =  0x02, \fBCU_AD_FORMAT_UNSIGNED_INT32\fP =  0x03, \fBCU_AD_FORMAT_SIGNED_INT8\fP =  0x08, \fBCU_AD_FORMAT_SIGNED_INT16\fP =  0x09, \fBCU_AD_FORMAT_SIGNED_INT32\fP =  0x0a, \fBCU_AD_FORMAT_HALF\fP =  0x10, \fBCU_AD_FORMAT_FLOAT\fP =  0x20 }"
.br
.ti -1c
.RI "enum \fBCUcomputemode\fP { \fBCU_COMPUTEMODE_DEFAULT\fP =  0, \fBCU_COMPUTEMODE_PROHIBITED\fP =  2, \fBCU_COMPUTEMODE_EXCLUSIVE_PROCESS\fP =  3 }"
.br
.ti -1c
.RI "enum \fBCUctx_flags\fP { \fBCU_CTX_SCHED_AUTO\fP =  0x00, \fBCU_CTX_SCHED_SPIN\fP =  0x01, \fBCU_CTX_SCHED_YIELD\fP =  0x02, \fBCU_CTX_SCHED_BLOCKING_SYNC\fP =  0x04, \fBCU_CTX_BLOCKING_SYNC\fP =  0x04, \fBCU_CTX_MAP_HOST\fP =  0x08, \fBCU_CTX_LMEM_RESIZE_TO_MAX\fP =  0x10 }"
.br
.ti -1c
.RI "enum \fBCUdevice_attribute\fP { \fBCU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK\fP =  1, \fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X\fP =  2, \fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y\fP =  3, \fBCU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z\fP =  4, \fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X\fP =  5, \fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y\fP =  6, \fBCU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z\fP =  7, \fBCU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK\fP =  8, \fBCU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK\fP =  8, \fBCU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY\fP =  9, \fBCU_DEVICE_ATTRIBUTE_WARP_SIZE\fP =  10, \fBCU_DEVICE_ATTRIBUTE_MAX_PITCH\fP =  11, \fBCU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK\fP =  12, \fBCU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK\fP =  12, \fBCU_DEVICE_ATTRIBUTE_CLOCK_RATE\fP =  13, \fBCU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT\fP =  14, \fBCU_DEVICE_ATTRIBUTE_GPU_OVERLAP\fP =  15, \fBCU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT\fP =  16, \fBCU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT\fP =  17, \fBCU_DEVICE_ATTRIBUTE_INTEGRATED\fP =  18, \fBCU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY\fP =  19, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_MODE\fP =  20, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH\fP =  21, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH\fP =  22, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT\fP =  23, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH\fP =  24, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT\fP =  25, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH\fP =  26, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH\fP =  27, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT\fP =  28, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS\fP =  29, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH\fP =  27, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT\fP =  28, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES\fP =  29, \fBCU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT\fP =  30, \fBCU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS\fP =  31, \fBCU_DEVICE_ATTRIBUTE_ECC_ENABLED\fP =  32, \fBCU_DEVICE_ATTRIBUTE_PCI_BUS_ID\fP =  33, \fBCU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID\fP =  34, \fBCU_DEVICE_ATTRIBUTE_TCC_DRIVER\fP =  35, \fBCU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE\fP =  36, \fBCU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH\fP =  37, \fBCU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE\fP =  38, \fBCU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR\fP =  39, \fBCU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT\fP =  40, \fBCU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING\fP =  41, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH\fP =  42, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS\fP =  43, \fBCU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER\fP =  44, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH\fP =  45, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT\fP =  46, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE\fP =  47, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE\fP =  48, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE\fP =  49, \fBCU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID\fP =  50, \fBCU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT\fP =  51, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH\fP =  52, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH\fP =  53, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS\fP =  54, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH\fP =  55, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH\fP =  56, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT\fP =  57, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH\fP =  58, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT\fP =  59, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH\fP =  60, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH\fP =  61, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS\fP =  62, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH\fP =  63, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT\fP =  64, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS\fP =  65, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH\fP =  66, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH\fP =  67, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS\fP =  68, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH\fP =  69, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH\fP =  70, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT\fP =  71, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH\fP =  72, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH\fP =  73, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT\fP =  74, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR\fP =  75, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR\fP =  76, \fBCU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH\fP =  77, \fBCU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED\fP =  78, \fBCU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED\fP =  79, \fBCU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED\fP =  80, \fBCU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR\fP =  81, \fBCU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR\fP =  82, \fBCU_DEVICE_ATTRIBUTE_MANAGED_MEMORY\fP =  83, \fBCU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD\fP =  84, \fBCU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID\fP =  85, \fBCU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED\fP =  86, \fBCU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO\fP =  87, \fBCU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS\fP =  88, \fBCU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS\fP =  89, \fBCU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED\fP =  90, \fBCU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM\fP =  91 }"
.br
.ti -1c
.RI "enum \fBCUdevice_P2PAttribute\fP { \fBCU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK\fP =  0x01, \fBCU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED\fP =  0x02, \fBCU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED\fP =  0x03 }"
.br
.ti -1c
.RI "enum \fBCUevent_flags\fP { \fBCU_EVENT_DEFAULT\fP =  0x0, \fBCU_EVENT_BLOCKING_SYNC\fP =  0x1, \fBCU_EVENT_DISABLE_TIMING\fP =  0x2, \fBCU_EVENT_INTERPROCESS\fP =  0x4 }"
.br
.ti -1c
.RI "enum \fBCUfilter_mode\fP { \fBCU_TR_FILTER_MODE_POINT\fP =  0, \fBCU_TR_FILTER_MODE_LINEAR\fP =  1 }"
.br
.ti -1c
.RI "enum \fBCUfunc_cache\fP { \fBCU_FUNC_CACHE_PREFER_NONE\fP =  0x00, \fBCU_FUNC_CACHE_PREFER_SHARED\fP =  0x01, \fBCU_FUNC_CACHE_PREFER_L1\fP =  0x02, \fBCU_FUNC_CACHE_PREFER_EQUAL\fP =  0x03 }"
.br
.ti -1c
.RI "enum \fBCUfunction_attribute\fP { \fBCU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK\fP =  0, \fBCU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES\fP =  1, \fBCU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES\fP =  2, \fBCU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES\fP =  3, \fBCU_FUNC_ATTRIBUTE_NUM_REGS\fP =  4, \fBCU_FUNC_ATTRIBUTE_PTX_VERSION\fP =  5, \fBCU_FUNC_ATTRIBUTE_BINARY_VERSION\fP =  6, \fBCU_FUNC_ATTRIBUTE_CACHE_MODE_CA\fP =  7 }"
.br
.ti -1c
.RI "enum \fBCUgraphicsMapResourceFlags\fP "
.br
.ti -1c
.RI "enum \fBCUgraphicsRegisterFlags\fP "
.br
.ti -1c
.RI "enum \fBCUipcMem_flags\fP { \fBCU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS\fP =  0x1 }"
.br
.ti -1c
.RI "enum \fBCUjit_cacheMode\fP { \fBCU_JIT_CACHE_OPTION_NONE\fP =  0, \fBCU_JIT_CACHE_OPTION_CG\fP, \fBCU_JIT_CACHE_OPTION_CA\fP }"
.br
.ti -1c
.RI "enum \fBCUjit_fallback\fP { \fBCU_PREFER_PTX\fP =  0, \fBCU_PREFER_BINARY\fP }"
.br
.ti -1c
.RI "enum \fBCUjit_option\fP { \fBCU_JIT_MAX_REGISTERS\fP =  0, \fBCU_JIT_THREADS_PER_BLOCK\fP, \fBCU_JIT_WALL_TIME\fP, \fBCU_JIT_INFO_LOG_BUFFER\fP, \fBCU_JIT_INFO_LOG_BUFFER_SIZE_BYTES\fP, \fBCU_JIT_ERROR_LOG_BUFFER\fP, \fBCU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES\fP, \fBCU_JIT_OPTIMIZATION_LEVEL\fP, \fBCU_JIT_TARGET_FROM_CUCONTEXT\fP, \fBCU_JIT_TARGET\fP, \fBCU_JIT_FALLBACK_STRATEGY\fP, \fBCU_JIT_GENERATE_DEBUG_INFO\fP, \fBCU_JIT_LOG_VERBOSE\fP, \fBCU_JIT_GENERATE_LINE_INFO\fP, \fBCU_JIT_CACHE_MODE\fP, \fBCU_JIT_NEW_SM3X_OPT\fP }"
.br
.ti -1c
.RI "enum \fBCUjit_target\fP { \fBCU_TARGET_COMPUTE_10\fP =  10, \fBCU_TARGET_COMPUTE_11\fP =  11, \fBCU_TARGET_COMPUTE_12\fP =  12, \fBCU_TARGET_COMPUTE_13\fP =  13, \fBCU_TARGET_COMPUTE_20\fP =  20, \fBCU_TARGET_COMPUTE_21\fP =  21, \fBCU_TARGET_COMPUTE_30\fP =  30, \fBCU_TARGET_COMPUTE_32\fP =  32, \fBCU_TARGET_COMPUTE_35\fP =  35, \fBCU_TARGET_COMPUTE_37\fP =  37, \fBCU_TARGET_COMPUTE_50\fP =  50, \fBCU_TARGET_COMPUTE_52\fP =  52, \fBCU_TARGET_COMPUTE_53\fP =  53, \fBCU_TARGET_COMPUTE_60\fP =  60, \fBCU_TARGET_COMPUTE_61\fP =  61, \fBCU_TARGET_COMPUTE_62\fP =  62 }"
.br
.ti -1c
.RI "enum \fBCUjitInputType\fP { \fBCU_JIT_INPUT_CUBIN\fP =  0, \fBCU_JIT_INPUT_PTX\fP, \fBCU_JIT_INPUT_FATBINARY\fP, \fBCU_JIT_INPUT_OBJECT\fP, \fBCU_JIT_INPUT_LIBRARY\fP }"
.br
.ti -1c
.RI "enum \fBCUlimit\fP { \fBCU_LIMIT_STACK_SIZE\fP =  0x00, \fBCU_LIMIT_PRINTF_FIFO_SIZE\fP =  0x01, \fBCU_LIMIT_MALLOC_HEAP_SIZE\fP =  0x02, \fBCU_LIMIT_DEV_RUNTIME_SYNC_DEPTH\fP =  0x03, \fBCU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT\fP =  0x04 }"
.br
.ti -1c
.RI "enum \fBCUmem_advise\fP { \fBCU_MEM_ADVISE_SET_READ_MOSTLY\fP =  1, \fBCU_MEM_ADVISE_UNSET_READ_MOSTLY\fP =  2, \fBCU_MEM_ADVISE_SET_PREFERRED_LOCATION\fP =  3, \fBCU_MEM_ADVISE_UNSET_PREFERRED_LOCATION\fP =  4, \fBCU_MEM_ADVISE_SET_ACCESSED_BY\fP =  5, \fBCU_MEM_ADVISE_UNSET_ACCESSED_BY\fP =  6 }"
.br
.ti -1c
.RI "enum \fBCUmem_range_attribute\fP { \fBCU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY\fP =  1, \fBCU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION\fP =  2, \fBCU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY\fP =  3, \fBCU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION\fP =  4 }"
.br
.ti -1c
.RI "enum \fBCUmemAttach_flags\fP { \fBCU_MEM_ATTACH_GLOBAL\fP =  0x1, \fBCU_MEM_ATTACH_HOST\fP =  0x2, \fBCU_MEM_ATTACH_SINGLE\fP =  0x4 }"
.br
.ti -1c
.RI "enum \fBCUmemorytype\fP { \fBCU_MEMORYTYPE_HOST\fP =  0x01, \fBCU_MEMORYTYPE_DEVICE\fP =  0x02, \fBCU_MEMORYTYPE_ARRAY\fP =  0x03, \fBCU_MEMORYTYPE_UNIFIED\fP =  0x04 }"
.br
.ti -1c
.RI "enum \fBCUoccupancy_flags\fP { \fBCU_OCCUPANCY_DEFAULT\fP =  0x0, \fBCU_OCCUPANCY_DISABLE_CACHING_OVERRIDE\fP =  0x1 }"
.br
.ti -1c
.RI "enum \fBCUpointer_attribute\fP { \fBCU_POINTER_ATTRIBUTE_CONTEXT\fP =  1, \fBCU_POINTER_ATTRIBUTE_MEMORY_TYPE\fP =  2, \fBCU_POINTER_ATTRIBUTE_DEVICE_POINTER\fP =  3, \fBCU_POINTER_ATTRIBUTE_HOST_POINTER\fP =  4, \fBCU_POINTER_ATTRIBUTE_P2P_TOKENS\fP =  5, \fBCU_POINTER_ATTRIBUTE_SYNC_MEMOPS\fP =  6, \fBCU_POINTER_ATTRIBUTE_BUFFER_ID\fP =  7, \fBCU_POINTER_ATTRIBUTE_IS_MANAGED\fP =  8 }"
.br
.ti -1c
.RI "enum \fBCUresourcetype\fP { \fBCU_RESOURCE_TYPE_ARRAY\fP =  0x00, \fBCU_RESOURCE_TYPE_MIPMAPPED_ARRAY\fP =  0x01, \fBCU_RESOURCE_TYPE_LINEAR\fP =  0x02, \fBCU_RESOURCE_TYPE_PITCH2D\fP =  0x03 }"
.br
.ti -1c
.RI "enum \fBCUresourceViewFormat\fP { \fBCU_RES_VIEW_FORMAT_NONE\fP =  0x00, \fBCU_RES_VIEW_FORMAT_UINT_1X8\fP =  0x01, \fBCU_RES_VIEW_FORMAT_UINT_2X8\fP =  0x02, \fBCU_RES_VIEW_FORMAT_UINT_4X8\fP =  0x03, \fBCU_RES_VIEW_FORMAT_SINT_1X8\fP =  0x04, \fBCU_RES_VIEW_FORMAT_SINT_2X8\fP =  0x05, \fBCU_RES_VIEW_FORMAT_SINT_4X8\fP =  0x06, \fBCU_RES_VIEW_FORMAT_UINT_1X16\fP =  0x07, \fBCU_RES_VIEW_FORMAT_UINT_2X16\fP =  0x08, \fBCU_RES_VIEW_FORMAT_UINT_4X16\fP =  0x09, \fBCU_RES_VIEW_FORMAT_SINT_1X16\fP =  0x0a, \fBCU_RES_VIEW_FORMAT_SINT_2X16\fP =  0x0b, \fBCU_RES_VIEW_FORMAT_SINT_4X16\fP =  0x0c, \fBCU_RES_VIEW_FORMAT_UINT_1X32\fP =  0x0d, \fBCU_RES_VIEW_FORMAT_UINT_2X32\fP =  0x0e, \fBCU_RES_VIEW_FORMAT_UINT_4X32\fP =  0x0f, \fBCU_RES_VIEW_FORMAT_SINT_1X32\fP =  0x10, \fBCU_RES_VIEW_FORMAT_SINT_2X32\fP =  0x11, \fBCU_RES_VIEW_FORMAT_SINT_4X32\fP =  0x12, \fBCU_RES_VIEW_FORMAT_FLOAT_1X16\fP =  0x13, \fBCU_RES_VIEW_FORMAT_FLOAT_2X16\fP =  0x14, \fBCU_RES_VIEW_FORMAT_FLOAT_4X16\fP =  0x15, \fBCU_RES_VIEW_FORMAT_FLOAT_1X32\fP =  0x16, \fBCU_RES_VIEW_FORMAT_FLOAT_2X32\fP =  0x17, \fBCU_RES_VIEW_FORMAT_FLOAT_4X32\fP =  0x18, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC1\fP =  0x19, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC2\fP =  0x1a, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC3\fP =  0x1b, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC4\fP =  0x1c, \fBCU_RES_VIEW_FORMAT_SIGNED_BC4\fP =  0x1d, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC5\fP =  0x1e, \fBCU_RES_VIEW_FORMAT_SIGNED_BC5\fP =  0x1f, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC6H\fP =  0x20, \fBCU_RES_VIEW_FORMAT_SIGNED_BC6H\fP =  0x21, \fBCU_RES_VIEW_FORMAT_UNSIGNED_BC7\fP =  0x22 }"
.br
.ti -1c
.RI "enum \fBCUresult\fP { \fBCUDA_SUCCESS\fP =  0, \fBCUDA_ERROR_INVALID_VALUE\fP =  1, \fBCUDA_ERROR_OUT_OF_MEMORY\fP =  2, \fBCUDA_ERROR_NOT_INITIALIZED\fP =  3, \fBCUDA_ERROR_DEINITIALIZED\fP =  4, \fBCUDA_ERROR_PROFILER_DISABLED\fP =  5, \fBCUDA_ERROR_PROFILER_NOT_INITIALIZED\fP =  6, \fBCUDA_ERROR_PROFILER_ALREADY_STARTED\fP =  7, \fBCUDA_ERROR_PROFILER_ALREADY_STOPPED\fP =  8, \fBCUDA_ERROR_NO_DEVICE\fP =  100, \fBCUDA_ERROR_INVALID_DEVICE\fP =  101, \fBCUDA_ERROR_INVALID_IMAGE\fP =  200, \fBCUDA_ERROR_INVALID_CONTEXT\fP =  201, \fBCUDA_ERROR_CONTEXT_ALREADY_CURRENT\fP =  202, \fBCUDA_ERROR_MAP_FAILED\fP =  205, \fBCUDA_ERROR_UNMAP_FAILED\fP =  206, \fBCUDA_ERROR_ARRAY_IS_MAPPED\fP =  207, \fBCUDA_ERROR_ALREADY_MAPPED\fP =  208, \fBCUDA_ERROR_NO_BINARY_FOR_GPU\fP =  209, \fBCUDA_ERROR_ALREADY_ACQUIRED\fP =  210, \fBCUDA_ERROR_NOT_MAPPED\fP =  211, \fBCUDA_ERROR_NOT_MAPPED_AS_ARRAY\fP =  212, \fBCUDA_ERROR_NOT_MAPPED_AS_POINTER\fP =  213, \fBCUDA_ERROR_ECC_UNCORRECTABLE\fP =  214, \fBCUDA_ERROR_UNSUPPORTED_LIMIT\fP =  215, \fBCUDA_ERROR_CONTEXT_ALREADY_IN_USE\fP =  216, \fBCUDA_ERROR_PEER_ACCESS_UNSUPPORTED\fP =  217, \fBCUDA_ERROR_INVALID_PTX\fP =  218, \fBCUDA_ERROR_INVALID_GRAPHICS_CONTEXT\fP =  219, \fBCUDA_ERROR_NVLINK_UNCORRECTABLE\fP =  220, \fBCUDA_ERROR_INVALID_SOURCE\fP =  300, \fBCUDA_ERROR_FILE_NOT_FOUND\fP =  301, \fBCUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND\fP =  302, \fBCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\fP =  303, \fBCUDA_ERROR_OPERATING_SYSTEM\fP =  304, \fBCUDA_ERROR_INVALID_HANDLE\fP =  400, \fBCUDA_ERROR_NOT_FOUND\fP =  500, \fBCUDA_ERROR_NOT_READY\fP =  600, \fBCUDA_ERROR_ILLEGAL_ADDRESS\fP =  700, \fBCUDA_ERROR_LAUNCH_OUT_OF_RESOURCES\fP =  701, \fBCUDA_ERROR_LAUNCH_TIMEOUT\fP =  702, \fBCUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING\fP =  703, \fBCUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED\fP =  704, \fBCUDA_ERROR_PEER_ACCESS_NOT_ENABLED\fP =  705, \fBCUDA_ERROR_PRIMARY_CONTEXT_ACTIVE\fP =  708, \fBCUDA_ERROR_CONTEXT_IS_DESTROYED\fP =  709, \fBCUDA_ERROR_ASSERT\fP =  710, \fBCUDA_ERROR_TOO_MANY_PEERS\fP =  711, \fBCUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED\fP =  712, \fBCUDA_ERROR_HOST_MEMORY_NOT_REGISTERED\fP =  713, \fBCUDA_ERROR_HARDWARE_STACK_ERROR\fP =  714, \fBCUDA_ERROR_ILLEGAL_INSTRUCTION\fP =  715, \fBCUDA_ERROR_MISALIGNED_ADDRESS\fP =  716, \fBCUDA_ERROR_INVALID_ADDRESS_SPACE\fP =  717, \fBCUDA_ERROR_INVALID_PC\fP =  718, \fBCUDA_ERROR_LAUNCH_FAILED\fP =  719, \fBCUDA_ERROR_NOT_PERMITTED\fP =  800, \fBCUDA_ERROR_NOT_SUPPORTED\fP =  801, \fBCUDA_ERROR_UNKNOWN\fP =  999 }"
.br
.ti -1c
.RI "enum \fBCUsharedconfig\fP { \fBCU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE\fP =  0x00, \fBCU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE\fP =  0x01, \fBCU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE\fP =  0x02 }"
.br
.ti -1c
.RI "enum \fBCUstream_flags\fP { \fBCU_STREAM_DEFAULT\fP =  0x0, \fBCU_STREAM_NON_BLOCKING\fP =  0x1 }"
.br
.ti -1c
.RI "enum \fBCUstreamBatchMemOpType\fP { \fBCU_STREAM_MEM_OP_WAIT_VALUE_32\fP =  1, \fBCU_STREAM_MEM_OP_WRITE_VALUE_32\fP =  2, \fBCU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES\fP =  3 }"
.br
.ti -1c
.RI "enum \fBCUstreamWaitValue_flags\fP { \fBCU_STREAM_WAIT_VALUE_GEQ\fP =  0x0, \fBCU_STREAM_WAIT_VALUE_EQ\fP =  0x1, \fBCU_STREAM_WAIT_VALUE_AND\fP =  0x2, \fBCU_STREAM_WAIT_VALUE_FLUSH\fP =  1<<30 }"
.br
.ti -1c
.RI "enum \fBCUstreamWriteValue_flags\fP { \fBCU_STREAM_WRITE_VALUE_DEFAULT\fP =  0x0, \fBCU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER\fP =  0x1 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBCUresult\fP \fBcuArray3DCreate\fP (\fBCUarray\fP *pHandle, const \fBCUDA_ARRAY3D_DESCRIPTOR\fP *pAllocateArray)"
.br
.RI "\fICreates a 3D CUDA array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuArray3DGetDescriptor\fP (\fBCUDA_ARRAY3D_DESCRIPTOR\fP *pArrayDescriptor, \fBCUarray\fP hArray)"
.br
.RI "\fIGet a 3D CUDA array descriptor. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuArrayCreate\fP (\fBCUarray\fP *pHandle, const \fBCUDA_ARRAY_DESCRIPTOR\fP *pAllocateArray)"
.br
.RI "\fICreates a 1D or 2D CUDA array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuArrayDestroy\fP (\fBCUarray\fP hArray)"
.br
.RI "\fIDestroys a CUDA array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuArrayGetDescriptor\fP (\fBCUDA_ARRAY_DESCRIPTOR\fP *pArrayDescriptor, \fBCUarray\fP hArray)"
.br
.RI "\fIGet a 1D or 2D CUDA array descriptor. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxAttach\fP (\fBCUcontext\fP *pctx, unsigned int flags)"
.br
.RI "\fIIncrement a context's usage-count. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxCreate\fP (\fBCUcontext\fP *pctx, unsigned int flags, \fBCUdevice\fP dev)"
.br
.RI "\fICreate a CUDA context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxDestroy\fP (\fBCUcontext\fP ctx)"
.br
.RI "\fIDestroy a CUDA context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxDetach\fP (\fBCUcontext\fP ctx)"
.br
.RI "\fIDecrement a context's usage-count. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxDisablePeerAccess\fP (\fBCUcontext\fP peerContext)"
.br
.RI "\fIDisables direct access to memory allocations in a peer context and unregisters any registered allocations. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxEnablePeerAccess\fP (\fBCUcontext\fP peerContext, unsigned int Flags)"
.br
.RI "\fIEnables direct access to memory allocations in a peer context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetApiVersion\fP (\fBCUcontext\fP ctx, unsigned int *version)"
.br
.RI "\fIGets the context's API version. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetCacheConfig\fP (\fBCUfunc_cache\fP *pconfig)"
.br
.RI "\fIReturns the preferred cache configuration for the current context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetCurrent\fP (\fBCUcontext\fP *pctx)"
.br
.RI "\fIReturns the CUDA context bound to the calling CPU thread. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetDevice\fP (\fBCUdevice\fP *device)"
.br
.RI "\fIReturns the device ID for the current context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetFlags\fP (unsigned int *flags)"
.br
.RI "\fIReturns the flags for the current context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetLimit\fP (size_t *pvalue, \fBCUlimit\fP limit)"
.br
.RI "\fIReturns resource limits. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetSharedMemConfig\fP (\fBCUsharedconfig\fP *pConfig)"
.br
.RI "\fIReturns the current shared memory configuration for the current context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxGetStreamPriorityRange\fP (int *leastPriority, int *greatestPriority)"
.br
.RI "\fIReturns numerical values that correspond to the least and greatest stream priorities. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxPopCurrent\fP (\fBCUcontext\fP *pctx)"
.br
.RI "\fIPops the current CUDA context from the current CPU thread. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxPushCurrent\fP (\fBCUcontext\fP ctx)"
.br
.RI "\fIPushes a context on the current CPU thread. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxSetCacheConfig\fP (\fBCUfunc_cache\fP config)"
.br
.RI "\fISets the preferred cache configuration for the current context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxSetCurrent\fP (\fBCUcontext\fP ctx)"
.br
.RI "\fIBinds the specified CUDA context to the calling CPU thread. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxSetLimit\fP (\fBCUlimit\fP limit, size_t value)"
.br
.RI "\fISet resource limits. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxSetSharedMemConfig\fP (\fBCUsharedconfig\fP config)"
.br
.RI "\fISets the shared memory configuration for the current context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuCtxSynchronize\fP (void)"
.br
.RI "\fIBlock for a context's tasks to complete. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceCanAccessPeer\fP (int *canAccessPeer, \fBCUdevice\fP dev, \fBCUdevice\fP peerDev)"
.br
.RI "\fIQueries if a device may directly access a peer device's memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceComputeCapability\fP (int *major, int *minor, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns the compute capability of the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGet\fP (\fBCUdevice\fP *device, int ordinal)"
.br
.RI "\fIReturns a handle to a compute device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetAttribute\fP (int *pi, \fBCUdevice_attribute\fP attrib, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns information about the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetByPCIBusId\fP (\fBCUdevice\fP *dev, const char *pciBusId)"
.br
.RI "\fIReturns a handle to a compute device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetCount\fP (int *count)"
.br
.RI "\fIReturns the number of compute-capable devices. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetName\fP (char *name, int len, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns an identifer string for the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetP2PAttribute\fP (int *value, \fBCUdevice_P2PAttribute\fP attrib, \fBCUdevice\fP srcDevice, \fBCUdevice\fP dstDevice)"
.br
.RI "\fIQueries attributes of the link between two devices. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetPCIBusId\fP (char *pciBusId, int len, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns a PCI Bus Id string for the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceGetProperties\fP (\fBCUdevprop\fP *prop, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns properties for a selected device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxGetState\fP (\fBCUdevice\fP dev, unsigned int *flags, int *active)"
.br
.RI "\fIGet the state of the primary context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxRelease\fP (\fBCUdevice\fP dev)"
.br
.RI "\fIRelease the primary context on the GPU. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxReset\fP (\fBCUdevice\fP dev)"
.br
.RI "\fIDestroy all allocations and reset all state on the primary context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxRetain\fP (\fBCUcontext\fP *pctx, \fBCUdevice\fP dev)"
.br
.RI "\fIRetain the primary context on the GPU. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDevicePrimaryCtxSetFlags\fP (\fBCUdevice\fP dev, unsigned int flags)"
.br
.RI "\fISet flags for the primary context. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDeviceTotalMem\fP (size_t *bytes, \fBCUdevice\fP dev)"
.br
.RI "\fIReturns the total amount of memory on the device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuDriverGetVersion\fP (int *driverVersion)"
.br
.RI "\fIReturns the CUDA driver version. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuEventCreate\fP (\fBCUevent\fP *phEvent, unsigned int Flags)"
.br
.RI "\fICreates an event. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuEventDestroy\fP (\fBCUevent\fP hEvent)"
.br
.RI "\fIDestroys an event. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuEventElapsedTime\fP (float *pMilliseconds, \fBCUevent\fP hStart, \fBCUevent\fP hEnd)"
.br
.RI "\fIComputes the elapsed time between two events. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuEventQuery\fP (\fBCUevent\fP hEvent)"
.br
.RI "\fIQueries an event's status. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuEventRecord\fP (\fBCUevent\fP hEvent, \fBCUstream\fP hStream)"
.br
.RI "\fIRecords an event. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuEventSynchronize\fP (\fBCUevent\fP hEvent)"
.br
.RI "\fIWaits for an event to complete. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuFuncGetAttribute\fP (int *pi, \fBCUfunction_attribute\fP attrib, \fBCUfunction\fP hfunc)"
.br
.RI "\fIReturns information about a function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuFuncSetBlockShape\fP (\fBCUfunction\fP hfunc, int x, int y, int z)"
.br
.RI "\fISets the block-dimensions for the function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuFuncSetCacheConfig\fP (\fBCUfunction\fP hfunc, \fBCUfunc_cache\fP config)"
.br
.RI "\fISets the preferred cache configuration for a device function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuFuncSetSharedMemConfig\fP (\fBCUfunction\fP hfunc, \fBCUsharedconfig\fP config)"
.br
.RI "\fISets the shared memory configuration for a device function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuFuncSetSharedSize\fP (\fBCUfunction\fP hfunc, unsigned int bytes)"
.br
.RI "\fISets the dynamic shared-memory size for the function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGetErrorName\fP (\fBCUresult\fP error, const char **pStr)"
.br
.RI "\fIGets the string representation of an error code enum name. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGetErrorString\fP (\fBCUresult\fP error, const char **pStr)"
.br
.RI "\fIGets the string description of an error code. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsMapResources\fP (unsigned int count, \fBCUgraphicsResource\fP *resources, \fBCUstream\fP hStream)"
.br
.RI "\fIMap graphics resources for access by CUDA. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsResourceGetMappedMipmappedArray\fP (\fBCUmipmappedArray\fP *pMipmappedArray, \fBCUgraphicsResource\fP resource)"
.br
.RI "\fIGet a mipmapped array through which to access a mapped graphics resource. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsResourceGetMappedPointer\fP (\fBCUdeviceptr\fP *pDevPtr, size_t *pSize, \fBCUgraphicsResource\fP resource)"
.br
.RI "\fIGet a device pointer through which to access a mapped graphics resource. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsResourceSetMapFlags\fP (\fBCUgraphicsResource\fP resource, unsigned int flags)"
.br
.RI "\fISet usage flags for mapping a graphics resource. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsSubResourceGetMappedArray\fP (\fBCUarray\fP *pArray, \fBCUgraphicsResource\fP resource, unsigned int arrayIndex, unsigned int mipLevel)"
.br
.RI "\fIGet an array through which to access a subresource of a mapped graphics resource. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsUnmapResources\fP (unsigned int count, \fBCUgraphicsResource\fP *resources, \fBCUstream\fP hStream)"
.br
.RI "\fIUnmap graphics resources. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuGraphicsUnregisterResource\fP (\fBCUgraphicsResource\fP resource)"
.br
.RI "\fIUnregisters a graphics resource for access by CUDA. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuInit\fP (unsigned int Flags)"
.br
.RI "\fIInitialize the CUDA driver API. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuIpcCloseMemHandle\fP (\fBCUdeviceptr\fP dptr)"
.br
.RI "\fIClose memory mapped with \fBcuIpcOpenMemHandle\fP. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuIpcGetEventHandle\fP (\fBCUipcEventHandle\fP *pHandle, \fBCUevent\fP event)"
.br
.RI "\fIGets an interprocess handle for a previously allocated event. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuIpcGetMemHandle\fP (\fBCUipcMemHandle\fP *pHandle, \fBCUdeviceptr\fP dptr)"
.br
.RI "\fIGets an interprocess memory handle for an existing device memory allocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuIpcOpenEventHandle\fP (\fBCUevent\fP *phEvent, \fBCUipcEventHandle\fP handle)"
.br
.RI "\fIOpens an interprocess event handle for use in the current process. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuIpcOpenMemHandle\fP (\fBCUdeviceptr\fP *pdptr, \fBCUipcMemHandle\fP handle, unsigned int Flags)"
.br
.RI "\fIOpens an interprocess memory handle exported from another process and returns a device pointer usable in the local process. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLaunch\fP (\fBCUfunction\fP f)"
.br
.RI "\fILaunches a CUDA function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLaunchGrid\fP (\fBCUfunction\fP f, int grid_width, int grid_height)"
.br
.RI "\fILaunches a CUDA function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLaunchGridAsync\fP (\fBCUfunction\fP f, int grid_width, int grid_height, \fBCUstream\fP hStream)"
.br
.RI "\fILaunches a CUDA function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLaunchKernel\fP (\fBCUfunction\fP f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, \fBCUstream\fP hStream, void **kernelParams, void **extra)"
.br
.RI "\fILaunches a CUDA function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkAddData\fP (CUlinkState state, \fBCUjitInputType\fP type, void *data, size_t size, const char *name, unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues)"
.br
.RI "\fIAdd an input to a pending linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkAddFile\fP (CUlinkState state, \fBCUjitInputType\fP type, const char *path, unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues)"
.br
.RI "\fIAdd a file input to a pending linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkComplete\fP (CUlinkState state, void **cubinOut, size_t *sizeOut)"
.br
.RI "\fIComplete a pending linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkCreate\fP (unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues, CUlinkState *stateOut)"
.br
.RI "\fICreates a pending JIT linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuLinkDestroy\fP (CUlinkState state)"
.br
.RI "\fIDestroys state for a JIT linker invocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemAdvise\fP (\fBCUdeviceptr\fP devPtr, size_t count, \fBCUmem_advise\fP advice, \fBCUdevice\fP device)"
.br
.RI "\fIAdvise about the usage of a given memory range. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemAlloc\fP (\fBCUdeviceptr\fP *dptr, size_t bytesize)"
.br
.RI "\fIAllocates device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemAllocHost\fP (void **pp, size_t bytesize)"
.br
.RI "\fIAllocates page-locked host memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemAllocManaged\fP (\fBCUdeviceptr\fP *dptr, size_t bytesize, unsigned int flags)"
.br
.RI "\fIAllocates memory that will be automatically managed by the Unified Memory system. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemAllocPitch\fP (\fBCUdeviceptr\fP *dptr, size_t *pPitch, size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes)"
.br
.RI "\fIAllocates pitched device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy\fP (\fBCUdeviceptr\fP dst, \fBCUdeviceptr\fP src, size_t ByteCount)"
.br
.RI "\fICopies memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy2D\fP (const \fBCUDA_MEMCPY2D\fP *pCopy)"
.br
.RI "\fICopies memory for 2D arrays. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy2DAsync\fP (const \fBCUDA_MEMCPY2D\fP *pCopy, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory for 2D arrays. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy2DUnaligned\fP (const \fBCUDA_MEMCPY2D\fP *pCopy)"
.br
.RI "\fICopies memory for 2D arrays. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy3D\fP (const \fBCUDA_MEMCPY3D\fP *pCopy)"
.br
.RI "\fICopies memory for 3D arrays. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy3DAsync\fP (const \fBCUDA_MEMCPY3D\fP *pCopy, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory for 3D arrays. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy3DPeer\fP (const \fBCUDA_MEMCPY3D_PEER\fP *pCopy)"
.br
.RI "\fICopies memory between contexts. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpy3DPeerAsync\fP (const \fBCUDA_MEMCPY3D_PEER\fP *pCopy, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory between contexts asynchronously. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyAsync\fP (\fBCUdeviceptr\fP dst, \fBCUdeviceptr\fP src, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory asynchronously. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyAtoA\fP (\fBCUarray\fP dstArray, size_t dstOffset, \fBCUarray\fP srcArray, size_t srcOffset, size_t ByteCount)"
.br
.RI "\fICopies memory from Array to Array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyAtoD\fP (\fBCUdeviceptr\fP dstDevice, \fBCUarray\fP srcArray, size_t srcOffset, size_t ByteCount)"
.br
.RI "\fICopies memory from Array to Device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyAtoH\fP (void *dstHost, \fBCUarray\fP srcArray, size_t srcOffset, size_t ByteCount)"
.br
.RI "\fICopies memory from Array to Host. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyAtoHAsync\fP (void *dstHost, \fBCUarray\fP srcArray, size_t srcOffset, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory from Array to Host. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyDtoA\fP (\fBCUarray\fP dstArray, size_t dstOffset, \fBCUdeviceptr\fP srcDevice, size_t ByteCount)"
.br
.RI "\fICopies memory from Device to Array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyDtoD\fP (\fBCUdeviceptr\fP dstDevice, \fBCUdeviceptr\fP srcDevice, size_t ByteCount)"
.br
.RI "\fICopies memory from Device to Device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyDtoDAsync\fP (\fBCUdeviceptr\fP dstDevice, \fBCUdeviceptr\fP srcDevice, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory from Device to Device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyDtoH\fP (void *dstHost, \fBCUdeviceptr\fP srcDevice, size_t ByteCount)"
.br
.RI "\fICopies memory from Device to Host. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyDtoHAsync\fP (void *dstHost, \fBCUdeviceptr\fP srcDevice, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory from Device to Host. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyHtoA\fP (\fBCUarray\fP dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount)"
.br
.RI "\fICopies memory from Host to Array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyHtoAAsync\fP (\fBCUarray\fP dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory from Host to Array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyHtoD\fP (\fBCUdeviceptr\fP dstDevice, const void *srcHost, size_t ByteCount)"
.br
.RI "\fICopies memory from Host to Device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyHtoDAsync\fP (\fBCUdeviceptr\fP dstDevice, const void *srcHost, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies memory from Host to Device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyPeer\fP (\fBCUdeviceptr\fP dstDevice, \fBCUcontext\fP dstContext, \fBCUdeviceptr\fP srcDevice, \fBCUcontext\fP srcContext, size_t ByteCount)"
.br
.RI "\fICopies device memory between two contexts. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemcpyPeerAsync\fP (\fBCUdeviceptr\fP dstDevice, \fBCUcontext\fP dstContext, \fBCUdeviceptr\fP srcDevice, \fBCUcontext\fP srcContext, size_t ByteCount, \fBCUstream\fP hStream)"
.br
.RI "\fICopies device memory between two contexts asynchronously. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemFree\fP (\fBCUdeviceptr\fP dptr)"
.br
.RI "\fIFrees device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemFreeHost\fP (void *p)"
.br
.RI "\fIFrees page-locked host memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemGetAddressRange\fP (\fBCUdeviceptr\fP *pbase, size_t *psize, \fBCUdeviceptr\fP dptr)"
.br
.RI "\fIGet information on memory allocations. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemGetInfo\fP (size_t *free, size_t *total)"
.br
.RI "\fIGets free and total memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemHostAlloc\fP (void **pp, size_t bytesize, unsigned int Flags)"
.br
.RI "\fIAllocates page-locked host memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemHostGetDevicePointer\fP (\fBCUdeviceptr\fP *pdptr, void *p, unsigned int Flags)"
.br
.RI "\fIPasses back device pointer of mapped pinned memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemHostGetFlags\fP (unsigned int *pFlags, void *p)"
.br
.RI "\fIPasses back flags that were used for a pinned allocation. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemHostRegister\fP (void *p, size_t bytesize, unsigned int Flags)"
.br
.RI "\fIRegisters an existing host memory range for use by CUDA. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemHostUnregister\fP (void *p)"
.br
.RI "\fIUnregisters a memory range that was registered with cuMemHostRegister. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemPrefetchAsync\fP (\fBCUdeviceptr\fP devPtr, size_t count, \fBCUdevice\fP dstDevice, \fBCUstream\fP hStream)"
.br
.RI "\fIPrefetches memory to the specified destination device. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemRangeGetAttribute\fP (void *data, size_t dataSize, \fBCUmem_range_attribute\fP attribute, \fBCUdeviceptr\fP devPtr, size_t count)"
.br
.RI "\fIQuery an attribute of a given memory range. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemRangeGetAttributes\fP (void **data, size_t *dataSizes, \fBCUmem_range_attribute\fP *attributes, size_t numAttributes, \fBCUdeviceptr\fP devPtr, size_t count)"
.br
.RI "\fIQuery attributes of a given memory range. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD16\fP (\fBCUdeviceptr\fP dstDevice, unsigned short us, size_t N)"
.br
.RI "\fIInitializes device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD16Async\fP (\fBCUdeviceptr\fP dstDevice, unsigned short us, size_t N, \fBCUstream\fP hStream)"
.br
.RI "\fISets device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD2D16\fP (\fBCUdeviceptr\fP dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height)"
.br
.RI "\fIInitializes device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD2D16Async\fP (\fBCUdeviceptr\fP dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, \fBCUstream\fP hStream)"
.br
.RI "\fISets device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD2D32\fP (\fBCUdeviceptr\fP dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height)"
.br
.RI "\fIInitializes device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD2D32Async\fP (\fBCUdeviceptr\fP dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, \fBCUstream\fP hStream)"
.br
.RI "\fISets device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD2D8\fP (\fBCUdeviceptr\fP dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height)"
.br
.RI "\fIInitializes device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD2D8Async\fP (\fBCUdeviceptr\fP dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, \fBCUstream\fP hStream)"
.br
.RI "\fISets device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD32\fP (\fBCUdeviceptr\fP dstDevice, unsigned int ui, size_t N)"
.br
.RI "\fIInitializes device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD32Async\fP (\fBCUdeviceptr\fP dstDevice, unsigned int ui, size_t N, \fBCUstream\fP hStream)"
.br
.RI "\fISets device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD8\fP (\fBCUdeviceptr\fP dstDevice, unsigned char uc, size_t N)"
.br
.RI "\fIInitializes device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMemsetD8Async\fP (\fBCUdeviceptr\fP dstDevice, unsigned char uc, size_t N, \fBCUstream\fP hStream)"
.br
.RI "\fISets device memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMipmappedArrayCreate\fP (\fBCUmipmappedArray\fP *pHandle, const \fBCUDA_ARRAY3D_DESCRIPTOR\fP *pMipmappedArrayDesc, unsigned int numMipmapLevels)"
.br
.RI "\fICreates a CUDA mipmapped array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMipmappedArrayDestroy\fP (\fBCUmipmappedArray\fP hMipmappedArray)"
.br
.RI "\fIDestroys a CUDA mipmapped array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuMipmappedArrayGetLevel\fP (\fBCUarray\fP *pLevelArray, \fBCUmipmappedArray\fP hMipmappedArray, unsigned int level)"
.br
.RI "\fIGets a mipmap level of a CUDA mipmapped array. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetFunction\fP (\fBCUfunction\fP *hfunc, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a function handle. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetGlobal\fP (\fBCUdeviceptr\fP *dptr, size_t *bytes, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a global pointer from a module. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetSurfRef\fP (\fBCUsurfref\fP *pSurfRef, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a handle to a surface reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleGetTexRef\fP (\fBCUtexref\fP *pTexRef, \fBCUmodule\fP hmod, const char *name)"
.br
.RI "\fIReturns a handle to a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoad\fP (\fBCUmodule\fP *module, const char *fname)"
.br
.RI "\fILoads a compute module. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoadData\fP (\fBCUmodule\fP *module, const void *image)"
.br
.RI "\fILoad a module's data. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoadDataEx\fP (\fBCUmodule\fP *module, const void *image, unsigned int numOptions, \fBCUjit_option\fP *options, void **optionValues)"
.br
.RI "\fILoad a module's data with options. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleLoadFatBinary\fP (\fBCUmodule\fP *module, const void *fatCubin)"
.br
.RI "\fILoad a module's data. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuModuleUnload\fP (\fBCUmodule\fP hmod)"
.br
.RI "\fIUnloads a module. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuOccupancyMaxActiveBlocksPerMultiprocessor\fP (int *numBlocks, \fBCUfunction\fP func, int blockSize, size_t dynamicSMemSize)"
.br
.RI "\fIReturns occupancy of a function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags\fP (int *numBlocks, \fBCUfunction\fP func, int blockSize, size_t dynamicSMemSize, unsigned int flags)"
.br
.RI "\fIReturns occupancy of a function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuOccupancyMaxPotentialBlockSize\fP (int *minGridSize, int *blockSize, \fBCUfunction\fP func, \fBCUoccupancyB2DSize\fP blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit)"
.br
.RI "\fISuggest a launch configuration with reasonable occupancy. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuOccupancyMaxPotentialBlockSizeWithFlags\fP (int *minGridSize, int *blockSize, \fBCUfunction\fP func, \fBCUoccupancyB2DSize\fP blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags)"
.br
.RI "\fISuggest a launch configuration with reasonable occupancy. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuParamSetf\fP (\fBCUfunction\fP hfunc, int offset, float value)"
.br
.RI "\fIAdds a floating-point parameter to the function's argument list. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuParamSeti\fP (\fBCUfunction\fP hfunc, int offset, unsigned int value)"
.br
.RI "\fIAdds an integer parameter to the function's argument list. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuParamSetSize\fP (\fBCUfunction\fP hfunc, unsigned int numbytes)"
.br
.RI "\fISets the parameter size for the function. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuParamSetTexRef\fP (\fBCUfunction\fP hfunc, int texunit, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIAdds a texture-reference to the function's argument list. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuParamSetv\fP (\fBCUfunction\fP hfunc, int offset, void *ptr, unsigned int numbytes)"
.br
.RI "\fIAdds arbitrary data to the function's argument list. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuPointerGetAttribute\fP (void *data, \fBCUpointer_attribute\fP attribute, \fBCUdeviceptr\fP ptr)"
.br
.RI "\fIReturns information about a pointer. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuPointerGetAttributes\fP (unsigned int numAttributes, \fBCUpointer_attribute\fP *attributes, void **data, \fBCUdeviceptr\fP ptr)"
.br
.RI "\fIReturns information about a pointer. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuPointerSetAttribute\fP (const void *value, \fBCUpointer_attribute\fP attribute, \fBCUdeviceptr\fP ptr)"
.br
.RI "\fISet attributes on a previously allocated memory region. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamAddCallback\fP (\fBCUstream\fP hStream, \fBCUstreamCallback\fP callback, void *userData, unsigned int flags)"
.br
.RI "\fIAdd a callback to a compute stream. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamAttachMemAsync\fP (\fBCUstream\fP hStream, \fBCUdeviceptr\fP dptr, size_t length, unsigned int flags)"
.br
.RI "\fIAttach memory to a stream asynchronously. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamBatchMemOp\fP (\fBCUstream\fP stream, unsigned int count, \fBCUstreamBatchMemOpParams\fP *paramArray, unsigned int flags)"
.br
.RI "\fIBatch operations to synchronize the stream via memory operations. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamCreate\fP (\fBCUstream\fP *phStream, unsigned int Flags)"
.br
.RI "\fICreate a stream. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamCreateWithPriority\fP (\fBCUstream\fP *phStream, unsigned int flags, int priority)"
.br
.RI "\fICreate a stream with the given priority. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamDestroy\fP (\fBCUstream\fP hStream)"
.br
.RI "\fIDestroys a stream. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamGetFlags\fP (\fBCUstream\fP hStream, unsigned int *flags)"
.br
.RI "\fIQuery the flags of a given stream. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamGetPriority\fP (\fBCUstream\fP hStream, int *priority)"
.br
.RI "\fIQuery the priority of a given stream. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamQuery\fP (\fBCUstream\fP hStream)"
.br
.RI "\fIDetermine status of a compute stream. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamSynchronize\fP (\fBCUstream\fP hStream)"
.br
.RI "\fIWait until a stream's tasks are completed. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamWaitEvent\fP (\fBCUstream\fP hStream, \fBCUevent\fP hEvent, unsigned int Flags)"
.br
.RI "\fIMake a compute stream wait on an event. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamWaitValue32\fP (\fBCUstream\fP stream, \fBCUdeviceptr\fP addr, cuuint32_t value, unsigned int flags)"
.br
.RI "\fIWait on a memory location. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuStreamWriteValue32\fP (\fBCUstream\fP stream, \fBCUdeviceptr\fP addr, cuuint32_t value, unsigned int flags)"
.br
.RI "\fIWrite a value to memory. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuSurfObjectCreate\fP (\fBCUsurfObject\fP *pSurfObject, const \fBCUDA_RESOURCE_DESC\fP *pResDesc)"
.br
.RI "\fICreates a surface object. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuSurfObjectDestroy\fP (\fBCUsurfObject\fP surfObject)"
.br
.RI "\fIDestroys a surface object. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuSurfObjectGetResourceDesc\fP (\fBCUDA_RESOURCE_DESC\fP *pResDesc, \fBCUsurfObject\fP surfObject)"
.br
.RI "\fIReturns a surface object's resource descriptor. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuSurfRefGetArray\fP (\fBCUarray\fP *phArray, \fBCUsurfref\fP hSurfRef)"
.br
.RI "\fIPasses back the CUDA array bound to a surface reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuSurfRefSetArray\fP (\fBCUsurfref\fP hSurfRef, \fBCUarray\fP hArray, unsigned int Flags)"
.br
.RI "\fISets the CUDA array for a surface reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexObjectCreate\fP (\fBCUtexObject\fP *pTexObject, const \fBCUDA_RESOURCE_DESC\fP *pResDesc, const \fBCUDA_TEXTURE_DESC\fP *pTexDesc, const \fBCUDA_RESOURCE_VIEW_DESC\fP *pResViewDesc)"
.br
.RI "\fICreates a texture object. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexObjectDestroy\fP (\fBCUtexObject\fP texObject)"
.br
.RI "\fIDestroys a texture object. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexObjectGetResourceDesc\fP (\fBCUDA_RESOURCE_DESC\fP *pResDesc, \fBCUtexObject\fP texObject)"
.br
.RI "\fIReturns a texture object's resource descriptor. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexObjectGetResourceViewDesc\fP (\fBCUDA_RESOURCE_VIEW_DESC\fP *pResViewDesc, \fBCUtexObject\fP texObject)"
.br
.RI "\fIReturns a texture object's resource view descriptor. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexObjectGetTextureDesc\fP (\fBCUDA_TEXTURE_DESC\fP *pTexDesc, \fBCUtexObject\fP texObject)"
.br
.RI "\fIReturns a texture object's texture descriptor. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefCreate\fP (\fBCUtexref\fP *pTexRef)"
.br
.RI "\fICreates a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefDestroy\fP (\fBCUtexref\fP hTexRef)"
.br
.RI "\fIDestroys a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetAddress\fP (\fBCUdeviceptr\fP *pdptr, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the address associated with a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetAddressMode\fP (\fBCUaddress_mode\fP *pam, \fBCUtexref\fP hTexRef, int dim)"
.br
.RI "\fIGets the addressing mode used by a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetArray\fP (\fBCUarray\fP *phArray, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the array bound to a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetBorderColor\fP (float *pBorderColor, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the border color used by a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetFilterMode\fP (\fBCUfilter_mode\fP *pfm, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the filter-mode used by a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetFlags\fP (unsigned int *pFlags, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the flags used by a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetFormat\fP (\fBCUarray_format\fP *pFormat, int *pNumChannels, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the format used by a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetMaxAnisotropy\fP (int *pmaxAniso, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the maximum anisotropy for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetMipmapFilterMode\fP (\fBCUfilter_mode\fP *pfm, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the mipmap filtering mode for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetMipmapLevelBias\fP (float *pbias, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the mipmap level bias for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetMipmapLevelClamp\fP (float *pminMipmapLevelClamp, float *pmaxMipmapLevelClamp, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the min/max mipmap level clamps for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefGetMipmappedArray\fP (\fBCUmipmappedArray\fP *phMipmappedArray, \fBCUtexref\fP hTexRef)"
.br
.RI "\fIGets the mipmapped array bound to a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetAddress\fP (size_t *ByteOffset, \fBCUtexref\fP hTexRef, \fBCUdeviceptr\fP dptr, size_t bytes)"
.br
.RI "\fIBinds an address as a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetAddress2D\fP (\fBCUtexref\fP hTexRef, const \fBCUDA_ARRAY_DESCRIPTOR\fP *desc, \fBCUdeviceptr\fP dptr, size_t Pitch)"
.br
.RI "\fIBinds an address as a 2D texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetAddressMode\fP (\fBCUtexref\fP hTexRef, int dim, \fBCUaddress_mode\fP am)"
.br
.RI "\fISets the addressing mode for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetArray\fP (\fBCUtexref\fP hTexRef, \fBCUarray\fP hArray, unsigned int Flags)"
.br
.RI "\fIBinds an array as a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetBorderColor\fP (\fBCUtexref\fP hTexRef, float *pBorderColor)"
.br
.RI "\fISets the border color for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetFilterMode\fP (\fBCUtexref\fP hTexRef, \fBCUfilter_mode\fP fm)"
.br
.RI "\fISets the filtering mode for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetFlags\fP (\fBCUtexref\fP hTexRef, unsigned int Flags)"
.br
.RI "\fISets the flags for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetFormat\fP (\fBCUtexref\fP hTexRef, \fBCUarray_format\fP fmt, int NumPackedComponents)"
.br
.RI "\fISets the format for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetMaxAnisotropy\fP (\fBCUtexref\fP hTexRef, unsigned int maxAniso)"
.br
.RI "\fISets the maximum anisotropy for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetMipmapFilterMode\fP (\fBCUtexref\fP hTexRef, \fBCUfilter_mode\fP fm)"
.br
.RI "\fISets the mipmap filtering mode for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetMipmapLevelBias\fP (\fBCUtexref\fP hTexRef, float bias)"
.br
.RI "\fISets the mipmap level bias for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetMipmapLevelClamp\fP (\fBCUtexref\fP hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp)"
.br
.RI "\fISets the mipmap min/max mipmap level clamps for a texture reference. \fP"
.ti -1c
.RI "\fBCUresult\fP \fBcuTexRefSetMipmappedArray\fP (\fBCUtexref\fP hTexRef, \fBCUmipmappedArray\fP hMipmappedArray, unsigned int Flags)"
.br
.RI "\fIBinds a mipmapped array to a texture reference. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Define Documentation"
.PP 
.SS "#define __CUDA_API_VERSION   8000"
.PP
CUDA API versioning support 
.SH "Author"
.PP 
Generated automatically by Doxygen from the source code.
