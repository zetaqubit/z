.TH "Device Enums" 3 "12 Jan 2017" "Version 1.1" "NVML" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Device Enums \- 
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBnvmlFlagDefault\fP   0x00"
.br
.RI "\fIGeneric flag used to specify the default behavior of some functions. See description of particular functions for details. \fP"
.ti -1c
.RI "#define \fBnvmlFlagForce\fP   0x01"
.br
.RI "\fIGeneric flag used to force some behavior. See description of particular functions for details. \fP"
.ti -1c
.RI "#define \fBnvmlEccBitType_t\fP   \fBnvmlMemoryErrorType_t\fP"
.br
.ti -1c
.RI "#define \fBNVML_SINGLE_BIT_ECC\fP   NVML_MEMORY_ERROR_TYPE_CORRECTED"
.br
.ti -1c
.RI "#define \fBNVML_DOUBLE_BIT_ECC\fP   NVML_MEMORY_ERROR_TYPE_UNCORRECTED"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBnvmlEnableState_t\fP { \fBNVML_FEATURE_DISABLED\fP =  0, \fBNVML_FEATURE_ENABLED\fP =  1 }"
.br
.ti -1c
.RI "enum \fBnvmlBrandType_t\fP "
.br
.ti -1c
.RI "enum \fBnvmlTemperatureThresholds_t\fP "
.br
.ti -1c
.RI "enum \fBnvmlTemperatureSensors_t\fP { \fBNVML_TEMPERATURE_GPU\fP =  0 }"
.br
.ti -1c
.RI "enum \fBnvmlComputeMode_t\fP { \fBNVML_COMPUTEMODE_DEFAULT\fP =  0, \fBNVML_COMPUTEMODE_EXCLUSIVE_THREAD\fP =  1, \fBNVML_COMPUTEMODE_PROHIBITED\fP =  2, \fBNVML_COMPUTEMODE_EXCLUSIVE_PROCESS\fP =  3 }"
.br
.ti -1c
.RI "enum \fBnvmlMemoryErrorType_t\fP { \fBNVML_MEMORY_ERROR_TYPE_CORRECTED\fP =  0, \fBNVML_MEMORY_ERROR_TYPE_UNCORRECTED\fP =  1, \fBNVML_MEMORY_ERROR_TYPE_COUNT\fP }"
.br
.ti -1c
.RI "enum \fBnvmlEccCounterType_t\fP { \fBNVML_VOLATILE_ECC\fP =  0, \fBNVML_AGGREGATE_ECC\fP =  1, \fBNVML_ECC_COUNTER_TYPE_COUNT\fP }"
.br
.ti -1c
.RI "enum \fBnvmlClockType_t\fP { \fBNVML_CLOCK_GRAPHICS\fP =  0, \fBNVML_CLOCK_SM\fP =  1, \fBNVML_CLOCK_MEM\fP =  2, \fBNVML_CLOCK_VIDEO\fP =  3 }"
.br
.ti -1c
.RI "enum \fBnvmlClockId_t\fP { \fBNVML_CLOCK_ID_CURRENT\fP =  0, \fBNVML_CLOCK_ID_APP_CLOCK_TARGET\fP =  1, \fBNVML_CLOCK_ID_APP_CLOCK_DEFAULT\fP =  2, \fBNVML_CLOCK_ID_CUSTOMER_BOOST_MAX\fP =  3 }"
.br
.ti -1c
.RI "enum \fBnvmlDriverModel_t\fP { \fBNVML_DRIVER_WDDM\fP =  0, \fBNVML_DRIVER_WDM\fP =  1 }"
.br
.ti -1c
.RI "enum \fBnvmlPstates_t\fP { \fBNVML_PSTATE_0\fP =  0, \fBNVML_PSTATE_1\fP =  1, \fBNVML_PSTATE_2\fP =  2, \fBNVML_PSTATE_3\fP =  3, \fBNVML_PSTATE_4\fP =  4, \fBNVML_PSTATE_5\fP =  5, \fBNVML_PSTATE_6\fP =  6, \fBNVML_PSTATE_7\fP =  7, \fBNVML_PSTATE_8\fP =  8, \fBNVML_PSTATE_9\fP =  9, \fBNVML_PSTATE_10\fP =  10, \fBNVML_PSTATE_11\fP =  11, \fBNVML_PSTATE_12\fP =  12, \fBNVML_PSTATE_13\fP =  13, \fBNVML_PSTATE_14\fP =  14, \fBNVML_PSTATE_15\fP =  15, \fBNVML_PSTATE_UNKNOWN\fP =  32 }"
.br
.ti -1c
.RI "enum \fBnvmlGpuOperationMode_t\fP { \fBNVML_GOM_ALL_ON\fP =  0, \fBNVML_GOM_COMPUTE\fP =  1, \fBNVML_GOM_LOW_DP\fP =  2 }"
.br
.ti -1c
.RI "enum \fBnvmlInforomObject_t\fP { \fBNVML_INFOROM_OEM\fP =  0, \fBNVML_INFOROM_ECC\fP =  1, \fBNVML_INFOROM_POWER\fP =  2, \fBNVML_INFOROM_COUNT\fP }"
.br
.ti -1c
.RI "enum \fBnvmlReturn_t\fP { \fBNVML_SUCCESS\fP =  0, \fBNVML_ERROR_UNINITIALIZED\fP =  1, \fBNVML_ERROR_INVALID_ARGUMENT\fP =  2, \fBNVML_ERROR_NOT_SUPPORTED\fP =  3, \fBNVML_ERROR_NO_PERMISSION\fP =  4, \fBNVML_ERROR_ALREADY_INITIALIZED\fP =  5, \fBNVML_ERROR_NOT_FOUND\fP =  6, \fBNVML_ERROR_INSUFFICIENT_SIZE\fP =  7, \fBNVML_ERROR_INSUFFICIENT_POWER\fP =  8, \fBNVML_ERROR_DRIVER_NOT_LOADED\fP =  9, \fBNVML_ERROR_TIMEOUT\fP =  10, \fBNVML_ERROR_IRQ_ISSUE\fP =  11, \fBNVML_ERROR_LIBRARY_NOT_FOUND\fP =  12, \fBNVML_ERROR_FUNCTION_NOT_FOUND\fP =  13, \fBNVML_ERROR_CORRUPTED_INFOROM\fP =  14, \fBNVML_ERROR_GPU_IS_LOST\fP =  15, \fBNVML_ERROR_RESET_REQUIRED\fP =  16, \fBNVML_ERROR_OPERATING_SYSTEM\fP =  17, \fBNVML_ERROR_LIB_RM_VERSION_MISMATCH\fP =  18, \fBNVML_ERROR_IN_USE\fP =  19, \fBNVML_ERROR_NO_DATA\fP =  20, \fBNVML_ERROR_UNKNOWN\fP =  999 }"
.br
.ti -1c
.RI "enum \fBnvmlMemoryLocation_t\fP { \fBNVML_MEMORY_LOCATION_L1_CACHE\fP =  0, \fBNVML_MEMORY_LOCATION_L2_CACHE\fP =  1, \fBNVML_MEMORY_LOCATION_DEVICE_MEMORY\fP =  2, \fBNVML_MEMORY_LOCATION_REGISTER_FILE\fP =  3, \fBNVML_MEMORY_LOCATION_TEXTURE_MEMORY\fP =  4, \fBNVML_MEMORY_LOCATION_TEXTURE_SHM\fP =  5, \fBNVML_MEMORY_LOCATION_COUNT\fP }"
.br
.ti -1c
.RI "enum \fBnvmlPageRetirementCause_t\fP { \fBNVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS\fP =  0, \fBNVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR\fP =  1 }"
.br
.ti -1c
.RI "enum \fBnvmlRestrictedAPI_t\fP { \fBNVML_RESTRICTED_API_SET_APPLICATION_CLOCKS\fP =  0, \fBNVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS\fP =  1 }"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define NVML_DOUBLE_BIT_ECC   NVML_MEMORY_ERROR_TYPE_UNCORRECTED"
.PP
Double bit ECC errors
.PP
\fBDeprecated\fP
.RS 4
Mapped to \fBNVML_MEMORY_ERROR_TYPE_UNCORRECTED\fP 
.RE
.PP

.SS "#define NVML_SINGLE_BIT_ECC   NVML_MEMORY_ERROR_TYPE_CORRECTED"
.PP
Single bit ECC errors
.PP
\fBDeprecated\fP
.RS 4
Mapped to \fBNVML_MEMORY_ERROR_TYPE_CORRECTED\fP 
.RE
.PP

.SS "#define nvmlEccBitType_t   \fBnvmlMemoryErrorType_t\fP"
.PP
ECC bit types.
.PP
\fBDeprecated\fP
.RS 4
See \fBnvmlMemoryErrorType_t\fP for a more flexible type 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBnvmlBrandType_t\fP"
.PP
* The Brand of the GPU 
.SS "enum \fBnvmlClockId_t\fP"
.PP
Clock Ids. These are used in combination with nvmlClockType_t to specify a single clock value. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_CLOCK_ID_CURRENT \fP\fP
Current actual clock value. 
.TP
\fB\fINVML_CLOCK_ID_APP_CLOCK_TARGET \fP\fP
Target application clock. 
.TP
\fB\fINVML_CLOCK_ID_APP_CLOCK_DEFAULT \fP\fP
Default application clock target. 
.TP
\fB\fINVML_CLOCK_ID_CUSTOMER_BOOST_MAX \fP\fP
OEM-defined maximum clock rate. 
.SS "enum \fBnvmlClockType_t\fP"
.PP
Clock types.
.PP
All speeds are in Mhz. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_CLOCK_GRAPHICS \fP\fP
Graphics clock domain. 
.TP
\fB\fINVML_CLOCK_SM \fP\fP
SM clock domain. 
.TP
\fB\fINVML_CLOCK_MEM \fP\fP
Memory clock domain. 
.TP
\fB\fINVML_CLOCK_VIDEO \fP\fP
Video encoder/decoder clock domain. 
.SS "enum \fBnvmlComputeMode_t\fP"
.PP
Compute mode.
.PP
NVML_COMPUTEMODE_EXCLUSIVE_PROCESS was added in CUDA 4.0. Earlier CUDA versions supported a single exclusive mode, which is equivalent to NVML_COMPUTEMODE_EXCLUSIVE_THREAD in CUDA 4.0 and beyond. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_COMPUTEMODE_DEFAULT \fP\fP
Default compute mode -- multiple contexts per device. 
.TP
\fB\fINVML_COMPUTEMODE_EXCLUSIVE_THREAD \fP\fP
Support Removed. 
.TP
\fB\fINVML_COMPUTEMODE_PROHIBITED \fP\fP
Compute-prohibited mode -- no contexts per device. 
.TP
\fB\fINVML_COMPUTEMODE_EXCLUSIVE_PROCESS \fP\fP
Compute-exclusive-process mode -- only one context per device, usable from multiple threads at a time. 
.SS "enum \fBnvmlDriverModel_t\fP"
.PP
Driver models.
.PP
Windows only. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_DRIVER_WDDM \fP\fP
WDDM driver model -- GPU treated as a display device. 
.TP
\fB\fINVML_DRIVER_WDM \fP\fP
WDM (TCC) model (recommended) -- GPU treated as a generic device. 
.SS "enum \fBnvmlEccCounterType_t\fP"
.PP
ECC counter types.
.PP
Note: Volatile counts are reset each time the driver loads. On Windows this is once per boot. On Linux this can be more frequent. On Linux the driver unloads when no active clients exist. If persistence mode is enabled or there is always a driver client active (e.g. X11), then Linux also sees per-boot behavior. If not, volatile counts are reset each time a compute app is run. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_VOLATILE_ECC \fP\fP
Volatile counts are reset each time the driver loads. 
.TP
\fB\fINVML_AGGREGATE_ECC \fP\fP
Aggregate counts persist across reboots (i.e. for the lifetime of the device). 
.TP
\fB\fINVML_ECC_COUNTER_TYPE_COUNT \fP\fP
Count of memory counter types. 
.SS "enum \fBnvmlEnableState_t\fP"
.PP
Generic enable/disable enum. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_FEATURE_DISABLED \fP\fP
Feature disabled. 
.TP
\fB\fINVML_FEATURE_ENABLED \fP\fP
Feature enabled. 
.SS "enum \fBnvmlGpuOperationMode_t\fP"
.PP
GPU Operation Mode
.PP
GOM allows to reduce power usage and optimize GPU throughput by disabling GPU features.
.PP
Each GOM is designed to meet specific user needs. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_GOM_ALL_ON \fP\fP
Everything is enabled and running at full speed. 
.TP
\fB\fINVML_GOM_COMPUTE \fP\fP
Designed for running only compute tasks. Graphics operations < are not allowed. 
.TP
\fB\fINVML_GOM_LOW_DP \fP\fP
Designed for running graphics applications that don't require < high bandwidth double precision. 
.SS "enum \fBnvmlInforomObject_t\fP"
.PP
Available infoROM objects. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_INFOROM_OEM \fP\fP
An object defined by OEM. 
.TP
\fB\fINVML_INFOROM_ECC \fP\fP
The ECC object determining the level of ECC support. 
.TP
\fB\fINVML_INFOROM_POWER \fP\fP
The power management object. 
.TP
\fB\fINVML_INFOROM_COUNT \fP\fP
This counts the number of infoROM objects the driver knows about. 
.SS "enum \fBnvmlMemoryErrorType_t\fP"
.PP
Memory error types 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_MEMORY_ERROR_TYPE_CORRECTED \fP\fP
A memory error that was corrected
.PP
For ECC errors, these are single bit errors For Texture memory, these are errors fixed by resend 
.TP
\fB\fINVML_MEMORY_ERROR_TYPE_UNCORRECTED \fP\fP
A memory error that was not corrected
.PP
For ECC errors, these are double bit errors For Texture memory, these are errors where the resend fails 
.TP
\fB\fINVML_MEMORY_ERROR_TYPE_COUNT \fP\fP
Count of memory error types. 
.SS "enum \fBnvmlMemoryLocation_t\fP"
.PP
Memory locations
.PP
See \fBnvmlDeviceGetMemoryErrorCounter\fP 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_MEMORY_LOCATION_L1_CACHE \fP\fP
GPU L1 Cache. 
.TP
\fB\fINVML_MEMORY_LOCATION_L2_CACHE \fP\fP
GPU L2 Cache. 
.TP
\fB\fINVML_MEMORY_LOCATION_DEVICE_MEMORY \fP\fP
GPU Device Memory. 
.TP
\fB\fINVML_MEMORY_LOCATION_REGISTER_FILE \fP\fP
GPU Register File. 
.TP
\fB\fINVML_MEMORY_LOCATION_TEXTURE_MEMORY \fP\fP
GPU Texture Memory. 
.TP
\fB\fINVML_MEMORY_LOCATION_TEXTURE_SHM \fP\fP
Shared memory. 
.TP
\fB\fINVML_MEMORY_LOCATION_COUNT \fP\fP
This counts the number of memory locations the driver knows about. 
.SS "enum \fBnvmlPageRetirementCause_t\fP"
.PP
Causes for page retirement 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS \fP\fP
Page was retired due to multiple single bit ECC error. 
.TP
\fB\fINVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR \fP\fP
Page was retired due to double bit ECC error. 
.SS "enum \fBnvmlPstates_t\fP"
.PP
Allowed PStates. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_PSTATE_0 \fP\fP
Performance state 0 -- Maximum Performance. 
.TP
\fB\fINVML_PSTATE_1 \fP\fP
Performance state 1. 
.TP
\fB\fINVML_PSTATE_2 \fP\fP
Performance state 2. 
.TP
\fB\fINVML_PSTATE_3 \fP\fP
Performance state 3. 
.TP
\fB\fINVML_PSTATE_4 \fP\fP
Performance state 4. 
.TP
\fB\fINVML_PSTATE_5 \fP\fP
Performance state 5. 
.TP
\fB\fINVML_PSTATE_6 \fP\fP
Performance state 6. 
.TP
\fB\fINVML_PSTATE_7 \fP\fP
Performance state 7. 
.TP
\fB\fINVML_PSTATE_8 \fP\fP
Performance state 8. 
.TP
\fB\fINVML_PSTATE_9 \fP\fP
Performance state 9. 
.TP
\fB\fINVML_PSTATE_10 \fP\fP
Performance state 10. 
.TP
\fB\fINVML_PSTATE_11 \fP\fP
Performance state 11. 
.TP
\fB\fINVML_PSTATE_12 \fP\fP
Performance state 12. 
.TP
\fB\fINVML_PSTATE_13 \fP\fP
Performance state 13. 
.TP
\fB\fINVML_PSTATE_14 \fP\fP
Performance state 14. 
.TP
\fB\fINVML_PSTATE_15 \fP\fP
Performance state 15 -- Minimum Performance. 
.TP
\fB\fINVML_PSTATE_UNKNOWN \fP\fP
Unknown performance state. 
.SS "enum \fBnvmlRestrictedAPI_t\fP"
.PP
API types that allow changes to default permission restrictions 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_RESTRICTED_API_SET_APPLICATION_CLOCKS \fP\fP
APIs that change application clocks, see nvmlDeviceSetApplicationsClocks < and see nvmlDeviceResetApplicationsClocks. 
.TP
\fB\fINVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS \fP\fP
APIs that enable/disable Auto Boosted clocks < see nvmlDeviceSetAutoBoostedClocksEnabled. 
.SS "enum \fBnvmlReturn_t\fP"
.PP
Return values for NVML API calls. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_SUCCESS \fP\fP
The operation was successful. 
.TP
\fB\fINVML_ERROR_UNINITIALIZED \fP\fP
NVML was not first initialized with \fBnvmlInit()\fP. 
.TP
\fB\fINVML_ERROR_INVALID_ARGUMENT \fP\fP
A supplied argument is invalid. 
.TP
\fB\fINVML_ERROR_NOT_SUPPORTED \fP\fP
The requested operation is not available on target device. 
.TP
\fB\fINVML_ERROR_NO_PERMISSION \fP\fP
The current user does not have permission for operation. 
.TP
\fB\fINVML_ERROR_ALREADY_INITIALIZED \fP\fP
Deprecated: Multiple initializations are now allowed through ref counting. 
.TP
\fB\fINVML_ERROR_NOT_FOUND \fP\fP
A query to find an object was unsuccessful. 
.TP
\fB\fINVML_ERROR_INSUFFICIENT_SIZE \fP\fP
An input argument is not large enough. 
.TP
\fB\fINVML_ERROR_INSUFFICIENT_POWER \fP\fP
A device's external power cables are not properly attached. 
.TP
\fB\fINVML_ERROR_DRIVER_NOT_LOADED \fP\fP
NVIDIA driver is not loaded. 
.TP
\fB\fINVML_ERROR_TIMEOUT \fP\fP
User provided timeout passed. 
.TP
\fB\fINVML_ERROR_IRQ_ISSUE \fP\fP
NVIDIA Kernel detected an interrupt issue with a GPU. 
.TP
\fB\fINVML_ERROR_LIBRARY_NOT_FOUND \fP\fP
NVML Shared Library couldn't be found or loaded. 
.TP
\fB\fINVML_ERROR_FUNCTION_NOT_FOUND \fP\fP
Local version of NVML doesn't implement this function. 
.TP
\fB\fINVML_ERROR_CORRUPTED_INFOROM \fP\fP
infoROM is corrupted 
.TP
\fB\fINVML_ERROR_GPU_IS_LOST \fP\fP
The GPU has fallen off the bus or has otherwise become inaccessible. 
.TP
\fB\fINVML_ERROR_RESET_REQUIRED \fP\fP
The GPU requires a reset before it can be used again. 
.TP
\fB\fINVML_ERROR_OPERATING_SYSTEM \fP\fP
The GPU control device has been blocked by the operating system/cgroups. 
.TP
\fB\fINVML_ERROR_LIB_RM_VERSION_MISMATCH \fP\fP
RM detects a driver/library version mismatch. 
.TP
\fB\fINVML_ERROR_IN_USE \fP\fP
An operation cannot be performed because the GPU is currently in use. 
.TP
\fB\fINVML_ERROR_NO_DATA \fP\fP
No data. 
.TP
\fB\fINVML_ERROR_UNKNOWN \fP\fP
An internal driver error occurred. 
.SS "enum \fBnvmlTemperatureSensors_t\fP"
.PP
Temperature sensors. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVML_TEMPERATURE_GPU \fP\fP
Temperature sensor for the GPU die. 
.SS "enum \fBnvmlTemperatureThresholds_t\fP"
.PP
Temperature thresholds. 
.SH "Author"
.PP 
Generated automatically by Doxygen for NVML from the source code.
