.TH "Device Queries" 3 "12 Jan 2017" "Version 1.1" "NVML" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Device Queries \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetCount\fP (unsigned int *deviceCount)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetHandleByIndex\fP (unsigned int index, nvmlDevice_t *device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetHandleBySerial\fP (const char *serial, nvmlDevice_t *device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetHandleByUUID\fP (const char *uuid, nvmlDevice_t *device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetHandleByPciBusId\fP (const char *pciBusId, nvmlDevice_t *device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetName\fP (nvmlDevice_t device, char *name, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetBrand\fP (nvmlDevice_t device, \fBnvmlBrandType_t\fP *type)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetIndex\fP (nvmlDevice_t device, unsigned int *index)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetSerial\fP (nvmlDevice_t device, char *serial, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetCpuAffinity\fP (nvmlDevice_t device, unsigned int cpuSetSize, unsigned long *cpuSet)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceSetCpuAffinity\fP (nvmlDevice_t device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceClearCpuAffinity\fP (nvmlDevice_t device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetTopologyCommonAncestor\fP (nvmlDevice_t device1, nvmlDevice_t device2, \fBnvmlGpuTopologyLevel_t\fP *pathInfo)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetTopologyNearestGpus\fP (nvmlDevice_t device, \fBnvmlGpuTopologyLevel_t\fP level, unsigned int *count, nvmlDevice_t *deviceArray)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlSystemGetTopologyGpuSet\fP (unsigned int cpuNumber, unsigned int *count, nvmlDevice_t *deviceArray)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetP2PStatus\fP (nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuP2PCapsIndex_t p2pIndex, nvmlGpuP2PStatus_t *p2pStatus)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetUUID\fP (nvmlDevice_t device, char *uuid, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMinorNumber\fP (nvmlDevice_t device, unsigned int *minorNumber)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetBoardPartNumber\fP (nvmlDevice_t device, char *partNumber, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetInforomVersion\fP (nvmlDevice_t device, \fBnvmlInforomObject_t\fP object, char *version, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetInforomImageVersion\fP (nvmlDevice_t device, char *version, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetInforomConfigurationChecksum\fP (nvmlDevice_t device, unsigned int *checksum)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceValidateInforom\fP (nvmlDevice_t device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetDisplayMode\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *display)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetDisplayActive\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *isActive)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPersistenceMode\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *mode)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPciInfo\fP (nvmlDevice_t device, \fBnvmlPciInfo_t\fP *pci)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMaxPcieLinkGeneration\fP (nvmlDevice_t device, unsigned int *maxLinkGen)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMaxPcieLinkWidth\fP (nvmlDevice_t device, unsigned int *maxLinkWidth)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetCurrPcieLinkGeneration\fP (nvmlDevice_t device, unsigned int *currLinkGen)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetCurrPcieLinkWidth\fP (nvmlDevice_t device, unsigned int *currLinkWidth)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPcieThroughput\fP (nvmlDevice_t device, \fBnvmlPcieUtilCounter_t\fP counter, unsigned int *value)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPcieReplayCounter\fP (nvmlDevice_t device, unsigned int *value)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetClockInfo\fP (nvmlDevice_t device, \fBnvmlClockType_t\fP type, unsigned int *clock)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMaxClockInfo\fP (nvmlDevice_t device, \fBnvmlClockType_t\fP type, unsigned int *clock)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetApplicationsClock\fP (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, unsigned int *clockMHz)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetDefaultApplicationsClock\fP (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, unsigned int *clockMHz)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceResetApplicationsClocks\fP (nvmlDevice_t device)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetClock\fP (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, \fBnvmlClockId_t\fP clockId, unsigned int *clockMHz)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMaxCustomerBoostClock\fP (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, unsigned int *clockMHz)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetSupportedMemoryClocks\fP (nvmlDevice_t device, unsigned int *count, unsigned int *clocksMHz)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetSupportedGraphicsClocks\fP (nvmlDevice_t device, unsigned int memoryClockMHz, unsigned int *count, unsigned int *clocksMHz)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetAutoBoostedClocksEnabled\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *isEnabled, \fBnvmlEnableState_t\fP *defaultIsEnabled)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceSetAutoBoostedClocksEnabled\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP enabled)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceSetDefaultAutoBoostedClocksEnabled\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP enabled, unsigned int flags)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetFanSpeed\fP (nvmlDevice_t device, unsigned int *speed)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetTemperature\fP (nvmlDevice_t device, \fBnvmlTemperatureSensors_t\fP sensorType, unsigned int *temp)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetTemperatureThreshold\fP (nvmlDevice_t device, \fBnvmlTemperatureThresholds_t\fP thresholdType, unsigned int *temp)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPerformanceState\fP (nvmlDevice_t device, \fBnvmlPstates_t\fP *pState)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetCurrentClocksThrottleReasons\fP (nvmlDevice_t device, unsigned long long *clocksThrottleReasons)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetSupportedClocksThrottleReasons\fP (nvmlDevice_t device, unsigned long long *supportedClocksThrottleReasons)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPowerState\fP (nvmlDevice_t device, \fBnvmlPstates_t\fP *pState)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPowerManagementMode\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *mode)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPowerManagementLimit\fP (nvmlDevice_t device, unsigned int *limit)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPowerManagementLimitConstraints\fP (nvmlDevice_t device, unsigned int *minLimit, unsigned int *maxLimit)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPowerManagementDefaultLimit\fP (nvmlDevice_t device, unsigned int *defaultLimit)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetPowerUsage\fP (nvmlDevice_t device, unsigned int *power)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetEnforcedPowerLimit\fP (nvmlDevice_t device, unsigned int *limit)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetGpuOperationMode\fP (nvmlDevice_t device, \fBnvmlGpuOperationMode_t\fP *current, \fBnvmlGpuOperationMode_t\fP *pending)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMemoryInfo\fP (nvmlDevice_t device, \fBnvmlMemory_t\fP *memory)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetComputeMode\fP (nvmlDevice_t device, \fBnvmlComputeMode_t\fP *mode)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetEccMode\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *current, \fBnvmlEnableState_t\fP *pending)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetBoardId\fP (nvmlDevice_t device, unsigned int *boardId)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMultiGpuBoard\fP (nvmlDevice_t device, unsigned int *multiGpuBool)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetTotalEccErrors\fP (nvmlDevice_t device, \fBnvmlMemoryErrorType_t\fP errorType, \fBnvmlEccCounterType_t\fP counterType, unsigned long long *eccCounts)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetDetailedEccErrors\fP (nvmlDevice_t device, \fBnvmlMemoryErrorType_t\fP errorType, \fBnvmlEccCounterType_t\fP counterType, \fBnvmlEccErrorCounts_t\fP *eccCounts)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetMemoryErrorCounter\fP (nvmlDevice_t device, \fBnvmlMemoryErrorType_t\fP errorType, \fBnvmlEccCounterType_t\fP counterType, \fBnvmlMemoryLocation_t\fP locationType, unsigned long long *count)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetUtilizationRates\fP (nvmlDevice_t device, \fBnvmlUtilization_t\fP *utilization)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetEncoderUtilization\fP (nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetDecoderUtilization\fP (nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetDriverModel\fP (nvmlDevice_t device, \fBnvmlDriverModel_t\fP *current, \fBnvmlDriverModel_t\fP *pending)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetVbiosVersion\fP (nvmlDevice_t device, char *version, unsigned int length)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetBridgeChipInfo\fP (nvmlDevice_t device, \fBnvmlBridgeChipHierarchy_t\fP *bridgeHierarchy)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetComputeRunningProcesses\fP (nvmlDevice_t device, unsigned int *infoCount, \fBnvmlProcessInfo_t\fP *infos)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetGraphicsRunningProcesses\fP (nvmlDevice_t device, unsigned int *infoCount, \fBnvmlProcessInfo_t\fP *infos)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceOnSameBoard\fP (nvmlDevice_t device1, nvmlDevice_t device2, int *onSameBoard)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetAPIRestriction\fP (nvmlDevice_t device, \fBnvmlRestrictedAPI_t\fP apiType, \fBnvmlEnableState_t\fP *isRestricted)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetSamples\fP (nvmlDevice_t device, \fBnvmlSamplingType_t\fP type, unsigned long long lastSeenTimeStamp, \fBnvmlValueType_t\fP *sampleValType, unsigned int *sampleCount, \fBnvmlSample_t\fP *samples)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetBAR1MemoryInfo\fP (nvmlDevice_t device, \fBnvmlBAR1Memory_t\fP *bar1Memory)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetViolationStatus\fP (nvmlDevice_t device, \fBnvmlPerfPolicyType_t\fP perfPolicyType, \fBnvmlViolationTime_t\fP *violTime)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetRetiredPages\fP (nvmlDevice_t device, \fBnvmlPageRetirementCause_t\fP cause, unsigned int *pageCount, unsigned long long *addresses)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceGetRetiredPagesPendingStatus\fP (nvmlDevice_t device, \fBnvmlEnableState_t\fP *isPending)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This chapter describes that queries that NVML can perform against each device. In each case the device is identified with an nvmlDevice_t handle. This handle is obtained by calling one of \fBnvmlDeviceGetHandleByIndex()\fP, \fBnvmlDeviceGetHandleBySerial()\fP, \fBnvmlDeviceGetHandleByPciBusId()\fP. or \fBnvmlDeviceGetHandleByUUID()\fP. 
.SH "Function Documentation"
.PP 
.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceClearCpuAffinity (nvmlDevice_t device)"
.PP
Clear all affinity bindings for the calling thread. Note, this is a change as of version 8.0 as older versions cleared the affinity for a calling process and all children.
.PP
For Kepler (TM) or newer fully supported devices. Supported on Linux only.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if the calling process has been successfully unbound
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetAPIRestriction (nvmlDevice_t device, \fBnvmlRestrictedAPI_t\fP apiType, \fBnvmlEnableState_t\fP * isRestricted)"
.PP
Retrieves the root/admin permissions on the target API. See \fInvmlRestrictedAPI_t\fP for the list of supported APIs. If an API is restricted only root users can call that API. See \fInvmlDeviceSetAPIRestriction\fP to change current permissions.
.PP
For all fully supported products.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIapiType\fP Target API type for this operation 
.br
\fIisRestricted\fP Reference in which to return the current restriction NVML_FEATURE_ENABLED indicates that the API is root-only NVML_FEATURE_DISABLED indicates that the API is accessible to all users
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIisRestricted\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIapiType\fP incorrect or \fIisRestricted\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if this query is not supported by the device or the device does not support the feature that is being queried (E.G. Enabling/disabling Auto Boosted clocks is not supported by the device)
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlRestrictedAPI_t\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetApplicationsClock (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, unsigned int * clockMHz)"
.PP
Retrieves the current setting of a clock that applications will use unless an overspec situation occurs. Can be changed using \fBnvmlDeviceSetApplicationsClocks\fP.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIclockType\fP Identify which clock domain to query 
.br
\fIclockMHz\fP Reference in which to return the clock in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclockMHz\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclockMHz\fP is NULL or \fIclockType\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetAutoBoostedClocksEnabled (nvmlDevice_t device, \fBnvmlEnableState_t\fP * isEnabled, \fBnvmlEnableState_t\fP * defaultIsEnabled)"
.PP
Retrieve the current state of Auto Boosted clocks on a device and store it in \fIisEnabled\fP 
.PP
For Kepler (TM) or newer fully supported devices.
.PP
Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates to maximize performance as thermal limits allow.
.PP
On Pascal and newer hardware, Auto Aoosted clocks are controlled through application clocks. Use \fBnvmlDeviceSetApplicationsClocks\fP and \fBnvmlDeviceResetApplicationsClocks\fP to control Auto Boost behavior.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIisEnabled\fP Where to store the current state of Auto Boosted clocks of the target device 
.br
\fIdefaultIsEnabled\fP Where to store the default Auto Boosted clocks behavior of the target device that the device will revert to when no applications are using the GPU
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP If \fIisEnabled\fP has been been set with the Auto Boosted clocks state of \fIdevice\fP 
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIisEnabled\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support Auto Boosted clocks
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetBAR1MemoryInfo (nvmlDevice_t device, \fBnvmlBAR1Memory_t\fP * bar1Memory)"
.PP
Gets Total, Available and Used size of BAR1 memory.
.PP
BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party devices (peer-to-peer on the PCIE bus).
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIbar1Memory\fP Reference in which BAR1 memory information is returned.
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if BAR1 memory is successfully retrieved
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIbar1Memory\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if this query is not supported by the device
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetBoardId (nvmlDevice_t device, unsigned int * boardId)"
.PP
Retrieves the device boardId from 0-N. Devices with the same boardId indicate GPUs connected to the same PLX. Use in conjunction with \fBnvmlDeviceGetMultiGpuBoard()\fP to decide if they are on the same board as well. The boardId returned is a unique ID for the current configuration. Uniqueness and ordering across reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will always return those values but they will always be different from each other).
.PP
For Fermi (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIboardId\fP Reference in which to return the device's board ID
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIboardId\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIboardId\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetBoardPartNumber (nvmlDevice_t device, char * partNumber, unsigned int length)"
.PP
Retrieves the the device board part number which is programmed into the board's InfoROM
.PP
For all products.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP Identifier of the target device 
.br
\fIpartNumber\fP Reference to the buffer to return 
.br
\fIlength\fP Length of the buffer reference
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpartNumber\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the needed VBIOS fields have not been filled
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIserial\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetBrand (nvmlDevice_t device, \fBnvmlBrandType_t\fP * type)"
.PP
Retrieves the brand of this device.
.PP
For all products.
.PP
The type is a member of \fBnvmlBrandType_t\fP defined above.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fItype\fP Reference in which to return the product brand type
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIname\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fItype\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetBridgeChipInfo (nvmlDevice_t device, \fBnvmlBridgeChipHierarchy_t\fP * bridgeHierarchy)"
.PP
Get Bridge Chip Information for all the bridge chips on the board.
.PP
For all fully supported products. Only applicable to multi-GPU products.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIbridgeHierarchy\fP Reference to the returned bridge chip Hierarchy
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if bridge chip exists
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIbridgeInfo\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if bridge chip not supported on the device
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetClock (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, \fBnvmlClockId_t\fP clockId, unsigned int * clockMHz)"
.PP
Retrieves the clock speed for the clock specified by the clock type and clock ID.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIclockType\fP Identify which clock domain to query 
.br
\fIclockId\fP Identify which clock in the domain to query 
.br
\fIclockMHz\fP Reference in which to return the clock in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclockMHz\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclockMHz\fP is NULL or \fIclockType\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetClockInfo (nvmlDevice_t device, \fBnvmlClockType_t\fP type, unsigned int * clock)"
.PP
Retrieves the current clock speeds for the device.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
See \fBnvmlClockType_t\fP for details on available clock information.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fItype\fP Identify which clock domain to query 
.br
\fIclock\fP Reference in which to return the clock speed in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclock\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclock\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device cannot report the specified clock
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetComputeMode (nvmlDevice_t device, \fBnvmlComputeMode_t\fP * mode)"
.PP
Retrieves the current compute mode for the device.
.PP
For all products.
.PP
See \fBnvmlComputeMode_t\fP for details on allowed compute modes.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImode\fP Reference in which to return the current compute mode
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImode\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImode\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetComputeMode()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetComputeRunningProcesses (nvmlDevice_t device, unsigned int * infoCount, \fBnvmlProcessInfo_t\fP * infos)"
.PP
Get information about processes with a compute context on a device
.PP
For Fermi (TM) or newer fully supported devices.
.PP
This function returns information only about compute running processes (e.g. CUDA application which have active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function.
.PP
To query the current number of running compute processes, call this function with *infoCount = 0. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call \fIinfos\fP is allowed to be NULL.
.PP
The usedGpuMemory field returned is all of the memory used by the application.
.PP
Keep in mind that information returned by this call is dynamic and the number of elements might change in time. Allocate more space for \fIinfos\fP table in case new compute processes are spawned.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIinfoCount\fP Reference in which to provide the \fIinfos\fP array size, and to return the number of returned elements 
.br
\fIinfos\fP Reference in which to return the process information
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIinfoCount\fP and \fIinfos\fP have been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIinfoCount\fP indicates that the \fIinfos\fP array is too small \fIinfoCount\fP will contain minimal amount of space necessary for the call to complete
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, either of \fIinfoCount\fP or \fIinfos\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlSystemGetProcessName\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetCount (unsigned int * deviceCount)"
.PP
Retrieves the number of compute devices in the system. A compute device is a single GPU.
.PP
For all products.
.PP
Note: New nvmlDeviceGetCount_v2 (default in NVML 5.319) returns count of all devices in the system even if nvmlDeviceGetHandleByIndex_v2 returns NVML_ERROR_NO_PERMISSION for such device. Update your code to handle this error, or use NVML 4.304 or older nvml header file. For backward binary compatibility reasons _v1 version of the API is still present in the shared library. Old _v1 version of nvmlDeviceGetCount doesn't count devices that NVML has no permission to talk to.
.PP
\fBParameters:\fP
.RS 4
\fIdeviceCount\fP Reference in which to return the number of accessible devices
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdeviceCount\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdeviceCount\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetCpuAffinity (nvmlDevice_t device, unsigned int cpuSetSize, unsigned long * cpuSet)"
.PP
Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2, result[0] = 0x3, result[1] = 0x3
.PP
For Kepler (TM) or newer fully supported devices. Supported on Linux only.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcpuSetSize\fP The size of the cpuSet array that is safe to access 
.br
\fIcpuSet\fP Array reference in which to return a bitmask of CPUs, 64 CPUs per unsigned long on 64-bit machines, 32 on 32-bit machines
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcpuAffinity\fP has been filled
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, cpuSetSize == 0, or cpuSet is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetCurrentClocksThrottleReasons (nvmlDevice_t device, unsigned long long * clocksThrottleReasons)"
.PP
Retrieves current clocks throttling reasons.
.PP
For all fully supported products.
.PP
\fBNote:\fP
.RS 4
More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIclocksThrottleReasons\fP Reference in which to return bitmask of active clocks throttle reasons
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclocksThrottleReasons\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclocksThrottleReasons\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBNvmlClocksThrottleReasons\fP 
.PP
\fBnvmlDeviceGetSupportedClocksThrottleReasons\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetCurrPcieLinkGeneration (nvmlDevice_t device, unsigned int * currLinkGen)"
.PP
Retrieves the current PCIe link generation
.PP
For Fermi (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcurrLinkGen\fP Reference in which to return the current PCIe link generation
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcurrLinkGen\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIcurrLinkGen\fP is null
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if PCIe link information is not available
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetCurrPcieLinkWidth (nvmlDevice_t device, unsigned int * currLinkWidth)"
.PP
Retrieves the current PCIe link width
.PP
For Fermi (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcurrLinkWidth\fP Reference in which to return the current PCIe link generation
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcurrLinkWidth\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIcurrLinkWidth\fP is null
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if PCIe link information is not available
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetDecoderUtilization (nvmlDevice_t device, unsigned int * utilization, unsigned int * samplingPeriodUs)"
.PP
Retrieves the current utilization and sampling size in microseconds for the Decoder
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIutilization\fP Reference to an unsigned int for decoder utilization info 
.br
\fIsamplingPeriodUs\fP Reference to an unsigned int for the sampling period in US
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIutilization\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIutilization\fP is NULL, or \fIsamplingPeriodUs\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetDefaultApplicationsClock (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, unsigned int * clockMHz)"
.PP
Retrieves the default applications clock that GPU boots with or defaults to after \fBnvmlDeviceResetApplicationsClocks\fP call.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIclockType\fP Identify which clock domain to query 
.br
\fIclockMHz\fP Reference in which to return the default clock in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclockMHz\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclockMHz\fP is NULL or \fIclockType\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetApplicationsClock\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetDetailedEccErrors (nvmlDevice_t device, \fBnvmlMemoryErrorType_t\fP errorType, \fBnvmlEccCounterType_t\fP counterType, \fBnvmlEccErrorCounts_t\fP * eccCounts)"
.PP
Retrieves the detailed ECC error counts for the device.
.PP
\fBDeprecated\fP
.RS 4
This API supports only a fixed set of ECC error locations On different GPU architectures different locations are supported See \fBnvmlDeviceGetMemoryErrorCounter\fP
.RE
.PP
For Fermi (TM) or newer fully supported devices. Only applicable to devices with ECC. Requires \fINVML_INFOROM_ECC\fP version 2.0 or higher to report aggregate location-based ECC counts. Requires \fINVML_INFOROM_ECC\fP version 1.0 or higher to report all other ECC counts. Requires ECC Mode to be enabled.
.PP
Detailed errors provide separate ECC counts for specific parts of the memory system.
.PP
Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported.
.PP
See \fBnvmlMemoryErrorType_t\fP for a description of available bit types.
.br
 See \fBnvmlEccCounterType_t\fP for a description of available counter types.
.br
 See \fBnvmlEccErrorCounts_t\fP for a description of provided detailed ECC counts.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIerrorType\fP Flag that specifies the type of the errors. 
.br
\fIcounterType\fP Flag that specifies the counter-type of the errors. 
.br
\fIeccCounts\fP Reference in which to return the specified ECC errors
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIeccCounts\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP, \fIerrorType\fP or \fIcounterType\fP is invalid, or \fIeccCounts\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceClearEccErrorCounts()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetDisplayActive (nvmlDevice_t device, \fBnvmlEnableState_t\fP * isActive)"
.PP
Retrieves the display active state for the device.
.PP
For all products.
.PP
This method indicates whether a display is initialized on the device. For example whether X Server is attached to this device and has allocated memory for the screen.
.PP
Display can be active even when no monitor is physically attached.
.PP
See \fBnvmlEnableState_t\fP for details on allowed modes.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIisActive\fP Reference in which to return the display active state
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIisActive\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIisActive\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetDisplayMode (nvmlDevice_t device, \fBnvmlEnableState_t\fP * display)"
.PP
Retrieves the display mode for the device.
.PP
For all products.
.PP
This method indicates whether a physical display (e.g. monitor) is currently connected to any of the device's connectors.
.PP
See \fBnvmlEnableState_t\fP for details on allowed modes.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIdisplay\fP Reference in which to return the display mode
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdisplay\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIdisplay\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetDriverModel (nvmlDevice_t device, \fBnvmlDriverModel_t\fP * current, \fBnvmlDriverModel_t\fP * pending)"
.PP
Retrieves the current and pending driver model for the device.
.PP
For Fermi (TM) or newer fully supported devices. For windows only.
.PP
On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached.
.PP
See \fBnvmlDriverModel_t\fP for details on available driver models.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcurrent\fP Reference in which to return the current driver model 
.br
\fIpending\fP Reference in which to return the pending driver model
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if either \fIcurrent\fP and/or \fIpending\fP have been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or both \fIcurrent\fP and \fIpending\fP are NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the platform is not windows
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetDriverModel()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetEccMode (nvmlDevice_t device, \fBnvmlEnableState_t\fP * current, \fBnvmlEnableState_t\fP * pending)"
.PP
Retrieves the current and pending ECC modes for the device.
.PP
For Fermi (TM) or newer fully supported devices. Only applicable to devices with ECC. Requires \fINVML_INFOROM_ECC\fP version 1.0 or higher.
.PP
Changing ECC modes requires a reboot. The 'pending' ECC mode refers to the target mode following the next reboot.
.PP
See \fBnvmlEnableState_t\fP for details on allowed modes.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcurrent\fP Reference in which to return the current ECC mode 
.br
\fIpending\fP Reference in which to return the pending ECC mode
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcurrent\fP and \fIpending\fP have been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or either \fIcurrent\fP or \fIpending\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetEccMode()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetEncoderUtilization (nvmlDevice_t device, unsigned int * utilization, unsigned int * samplingPeriodUs)"
.PP
Retrieves the current utilization and sampling size in microseconds for the Encoder
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIutilization\fP Reference to an unsigned int for encoder utilization info 
.br
\fIsamplingPeriodUs\fP Reference to an unsigned int for the sampling period in US
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIutilization\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIutilization\fP is NULL, or \fIsamplingPeriodUs\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetEnforcedPowerLimit (nvmlDevice_t device, unsigned int * limit)"
.PP
Get the effective power limit that the driver enforces after taking into account all limiters
.PP
Note: This can be different from the \fBnvmlDeviceGetPowerManagementLimit\fP if other limits are set elsewhere This includes the out of band power limit interface
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The device to communicate with 
.br
\fIlimit\fP Reference in which to return the power management limit in milliwatts
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIlimit\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIlimit\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetFanSpeed (nvmlDevice_t device, unsigned int * speed)"
.PP
Retrieves the intended operating speed of the device's fan.
.PP
Note: The reported speed is the intended fan speed. If the fan is physically blocked and unable to spin, the output will not match the actual fan speed.
.PP
For all discrete products with dedicated fans.
.PP
The fan speed is expressed as a percent of the maximum, i.e. full speed is 100%.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIspeed\fP Reference in which to return the fan speed percentage
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIspeed\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIspeed\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not have a fan
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetGpuOperationMode (nvmlDevice_t device, \fBnvmlGpuOperationMode_t\fP * current, \fBnvmlGpuOperationMode_t\fP * pending)"
.PP
Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot).
.PP
For GK110 M-class and X-class Tesla (TM) products from the Kepler family. Modes \fBNVML_GOM_LOW_DP\fP and \fBNVML_GOM_ALL_ON\fP are supported on fully supported GeForce products. Not supported on Quadro (R) and Tesla (TM) C-class products.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcurrent\fP Reference in which to return the current GOM 
.br
\fIpending\fP Reference in which to return the pending GOM
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImode\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIcurrent\fP or \fIpending\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlGpuOperationMode_t\fP 
.PP
\fBnvmlDeviceSetGpuOperationMode\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetGraphicsRunningProcesses (nvmlDevice_t device, unsigned int * infoCount, \fBnvmlProcessInfo_t\fP * infos)"
.PP
Get information about processes with a graphics context on a device
.PP
For Kepler (TM) or newer fully supported devices.
.PP
This function returns information only about graphics based processes (eg. applications using OpenGL, DirectX)
.PP
To query the current number of running graphics processes, call this function with *infoCount = 0. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call \fIinfos\fP is allowed to be NULL.
.PP
The usedGpuMemory field returned is all of the memory used by the application.
.PP
Keep in mind that information returned by this call is dynamic and the number of elements might change in time. Allocate more space for \fIinfos\fP table in case new graphics processes are spawned.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIinfoCount\fP Reference in which to provide the \fIinfos\fP array size, and to return the number of returned elements 
.br
\fIinfos\fP Reference in which to return the process information
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIinfoCount\fP and \fIinfos\fP have been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIinfoCount\fP indicates that the \fIinfos\fP array is too small \fIinfoCount\fP will contain minimal amount of space necessary for the call to complete
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, either of \fIinfoCount\fP or \fIinfos\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlSystemGetProcessName\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetHandleByIndex (unsigned int index, nvmlDevice_t * device)"
.PP
Acquire the handle for a particular device, based on its index.
.PP
For all products.
.PP
Valid indices are derived from the \fIaccessibleDevices\fP count returned by \fBnvmlDeviceGetCount()\fP. For example, if \fIaccessibleDevices\fP is 2 the valid indices are 0 and 1, corresponding to GPU 0 and GPU 1.
.PP
The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it is recommended that devices be looked up by their PCI ids or UUID. See \fBnvmlDeviceGetHandleByUUID()\fP and \fBnvmlDeviceGetHandleByPciBusId()\fP.
.PP
Note: The NVML index may not correlate with other APIs, such as the CUDA device index.
.PP
Starting from NVML 5, this API causes NVML to initialize the target GPU NVML may initialize additional GPUs if:
.IP "\(bu" 2
The target GPU is an SLI slave
.PP
.PP
Note: New nvmlDeviceGetCount_v2 (default in NVML 5.319) returns count of all devices in the system even if nvmlDeviceGetHandleByIndex_v2 returns NVML_ERROR_NO_PERMISSION for such device. Update your code to handle this error, or use NVML 4.304 or older nvml header file. For backward binary compatibility reasons _v1 version of the API is still present in the shared library. Old _v1 version of nvmlDeviceGetCount doesn't count devices that NVML has no permission to talk to.
.PP
This means that nvmlDeviceGetHandleByIndex_v2 and _v1 can return different devices for the same index. If you don't touch macros that map old (_v1) versions to _v2 versions at the top of the file you don't need to worry about that.
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP The index of the target GPU, >= 0 and < \fIaccessibleDevices\fP 
.br
\fIdevice\fP Reference in which to return the device handle
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdevice\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIindex\fP is invalid or \fIdevice\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_POWER\fP if any attached devices have improperly attached external power cables
.IP "\(bu" 2
\fBNVML_ERROR_NO_PERMISSION\fP if the user doesn't have permission to talk to this device
.IP "\(bu" 2
\fBNVML_ERROR_IRQ_ISSUE\fP if NVIDIA kernel detected an interrupt issue with the attached GPUs
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetIndex\fP 
.PP
\fBnvmlDeviceGetCount\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetHandleByPciBusId (const char * pciBusId, nvmlDevice_t * device)"
.PP
Acquire the handle for a particular device, based on its PCI bus id.
.PP
For all products.
.PP
This value corresponds to the \fBnvmlPciInfo_t::busId\fP returned by \fBnvmlDeviceGetPciInfo()\fP.
.PP
Starting from NVML 5, this API causes NVML to initialize the target GPU NVML may initialize additional GPUs if:
.IP "\(bu" 2
The target GPU is an SLI slave
.PP
.PP
\fBNote:\fP
.RS 4
NVML 4.304 and older version of nvmlDeviceGetHandleByPciBusId'_v1' returns NVML_ERROR_NOT_FOUND instead of NVML_ERROR_NO_PERMISSION.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpciBusId\fP The PCI bus id of the target GPU 
.br
\fIdevice\fP Reference in which to return the device handle
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdevice\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIpciBusId\fP is invalid or \fIdevice\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_FOUND\fP if \fIpciBusId\fP does not match a valid device on the system
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_POWER\fP if the attached device has improperly attached external power cables
.IP "\(bu" 2
\fBNVML_ERROR_NO_PERMISSION\fP if the user doesn't have permission to talk to this device
.IP "\(bu" 2
\fBNVML_ERROR_IRQ_ISSUE\fP if NVIDIA kernel detected an interrupt issue with the attached GPUs
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetHandleBySerial (const char * serial, nvmlDevice_t * device)"
.PP
Acquire the handle for a particular device, based on its board serial number.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
This number corresponds to the value printed directly on the board, and to the value returned by \fBnvmlDeviceGetSerial()\fP.
.PP
\fBDeprecated\fP
.RS 4
Since more than one GPU can exist on a single board this function is deprecated in favor of \fBnvmlDeviceGetHandleByUUID\fP. For dual GPU boards this function will return NVML_ERROR_INVALID_ARGUMENT.
.RE
.PP
Starting from NVML 5, this API causes NVML to initialize the target GPU NVML may initialize additional GPUs as it searches for the target GPU
.PP
\fBParameters:\fP
.RS 4
\fIserial\fP The board serial number of the target GPU 
.br
\fIdevice\fP Reference in which to return the device handle
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdevice\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIserial\fP is invalid, \fIdevice\fP is NULL or more than one device has the same serial (dual GPU boards)
.IP "\(bu" 2
\fBNVML_ERROR_NOT_FOUND\fP if \fIserial\fP does not match a valid device on the system
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_POWER\fP if any attached devices have improperly attached external power cables
.IP "\(bu" 2
\fBNVML_ERROR_IRQ_ISSUE\fP if NVIDIA kernel detected an interrupt issue with the attached GPUs
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if any GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetSerial\fP 
.PP
\fBnvmlDeviceGetHandleByUUID\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetHandleByUUID (const char * uuid, nvmlDevice_t * device)"
.PP
Acquire the handle for a particular device, based on its globally unique immutable UUID associated with each device.
.PP
For all products.
.PP
\fBParameters:\fP
.RS 4
\fIuuid\fP The UUID of the target GPU 
.br
\fIdevice\fP Reference in which to return the device handle
.RE
.PP
Starting from NVML 5, this API causes NVML to initialize the target GPU NVML may initialize additional GPUs as it searches for the target GPU
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdevice\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIuuid\fP is invalid or \fIdevice\fP is null
.IP "\(bu" 2
\fBNVML_ERROR_NOT_FOUND\fP if \fIuuid\fP does not match a valid device on the system
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_POWER\fP if any attached devices have improperly attached external power cables
.IP "\(bu" 2
\fBNVML_ERROR_IRQ_ISSUE\fP if NVIDIA kernel detected an interrupt issue with the attached GPUs
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if any GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetUUID\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetIndex (nvmlDevice_t device, unsigned int * index)"
.PP
Retrieves the NVML index of this device.
.PP
For all products.
.PP
Valid indices are derived from the \fIaccessibleDevices\fP count returned by \fBnvmlDeviceGetCount()\fP. For example, if \fIaccessibleDevices\fP is 2 the valid indices are 0 and 1, corresponding to GPU 0 and GPU 1.
.PP
The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it is recommended that devices be looked up by their PCI ids or GPU UUID. See \fBnvmlDeviceGetHandleByPciBusId()\fP and \fBnvmlDeviceGetHandleByUUID()\fP.
.PP
Note: The NVML index may not correlate with other APIs, such as the CUDA device index.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIindex\fP Reference in which to return the NVML index of the device
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIindex\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIindex\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetHandleByIndex()\fP 
.PP
\fBnvmlDeviceGetCount()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetInforomConfigurationChecksum (nvmlDevice_t device, unsigned int * checksum)"
.PP
Retrieves the checksum of the configuration stored in the device's infoROM.
.PP
For all products with an inforom.
.PP
Can be used to make sure that two GPUs have the exact same configuration. Current checksum takes into account configuration stored in PWR and ECC infoROM objects. Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC)
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIchecksum\fP Reference in which to return the infoROM configuration checksum
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIchecksum\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_CORRUPTED_INFOROM\fP if the device's checksum couldn't be retrieved due to infoROM corruption
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIchecksum\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetInforomImageVersion (nvmlDevice_t device, char * version, unsigned int length)"
.PP
Retrieves the global infoROM image version
.PP
For all products with an inforom.
.PP
Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board in contrast to infoROM object version which is only an indicator of supported features. Version string will not exceed 16 characters in length (including the NULL terminator). See \fBnvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIversion\fP Reference in which to return the infoROM image version 
.br
\fIlength\fP The maximum allowed length of the string returned in \fIversion\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIversion\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIversion\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIlength\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not have an infoROM
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetInforomVersion\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetInforomVersion (nvmlDevice_t device, \fBnvmlInforomObject_t\fP object, char * version, unsigned int length)"
.PP
Retrieves the version information for the device's infoROM object.
.PP
For all products with an inforom.
.PP
Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate ECC counts. The version of the data structures in this memory may change from time to time. It will not exceed 16 characters in length (including the NULL terminator). See \fBnvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE\fP.
.PP
See \fBnvmlInforomObject_t\fP for details on the available infoROM objects.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIobject\fP The target infoROM object 
.br
\fIversion\fP Reference in which to return the infoROM version 
.br
\fIlength\fP The maximum allowed length of the string returned in \fIversion\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIversion\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIversion\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIlength\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not have an infoROM
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetInforomImageVersion\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMaxClockInfo (nvmlDevice_t device, \fBnvmlClockType_t\fP type, unsigned int * clock)"
.PP
Retrieves the maximum clock speeds for the device.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
See \fBnvmlClockType_t\fP for details on available clock information.
.PP
\fBNote:\fP
.RS 4
On GPUs from Fermi family current P0 clocks (reported by \fBnvmlDeviceGetClockInfo\fP) can differ from max clocks by few MHz.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fItype\fP Identify which clock domain to query 
.br
\fIclock\fP Reference in which to return the clock speed in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclock\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclock\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device cannot report the specified clock
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMaxCustomerBoostClock (nvmlDevice_t device, \fBnvmlClockType_t\fP clockType, unsigned int * clockMHz)"
.PP
Retrieves the customer defined maximum boost clock speed specified by the given clock type.
.PP
For newer than Maxwell (TM) fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIclockType\fP Identify which clock domain to query 
.br
\fIclockMHz\fP Reference in which to return the clock in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIclockMHz\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclockMHz\fP is NULL or \fIclockType\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device or the \fIclockType\fP on this device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMaxPcieLinkGeneration (nvmlDevice_t device, unsigned int * maxLinkGen)"
.PP
Retrieves the maximum PCIe link generation possible with this device and system
.PP
I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will report is generation 1.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImaxLinkGen\fP Reference in which to return the max PCIe link generation
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImaxLinkGen\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImaxLinkGen\fP is null
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if PCIe link information is not available
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMaxPcieLinkWidth (nvmlDevice_t device, unsigned int * maxLinkWidth)"
.PP
Retrieves the maximum PCIe link width possible with this device and system
.PP
I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report a max link width of 8.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImaxLinkWidth\fP Reference in which to return the max PCIe link generation
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImaxLinkWidth\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImaxLinkWidth\fP is null
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if PCIe link information is not available
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMemoryErrorCounter (nvmlDevice_t device, \fBnvmlMemoryErrorType_t\fP errorType, \fBnvmlEccCounterType_t\fP counterType, \fBnvmlMemoryLocation_t\fP locationType, unsigned long long * count)"
.PP
Retrieves the requested memory error counter for the device.
.PP
For Fermi (TM) or newer fully supported devices. Requires \fINVML_INFOROM_ECC\fP version 2.0 or higher to report aggregate location-based memory error counts. Requires \fINVML_INFOROM_ECC\fP version 1.0 or higher to report all other memory error counts.
.PP
Only applicable to devices with ECC.
.PP
Requires ECC Mode to be enabled.
.PP
See \fBnvmlMemoryErrorType_t\fP for a description of available memory error types.
.br
 See \fBnvmlEccCounterType_t\fP for a description of available counter types.
.br
 See \fBnvmlMemoryLocation_t\fP for a description of available counter locations.
.br
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIerrorType\fP Flag that specifies the type of error. 
.br
\fIcounterType\fP Flag that specifies the counter-type of the errors. 
.br
\fIlocationType\fP Specifies the location of the counter. 
.br
\fIcount\fP Reference in which to return the ECC counter
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcount\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP, \fIbitTyp\fP,e \fIcounterType\fP or \fIlocationType\fP is invalid, or \fIcount\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support ECC error reporting in the specified memory
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMemoryInfo (nvmlDevice_t device, \fBnvmlMemory_t\fP * memory)"
.PP
Retrieves the amount of used, free and total memory available on the device, in bytes.
.PP
For all products.
.PP
Enabling ECC reduces the amount of total available memory, due to the extra required parity bits. Under WDDM most device memory is allocated and managed on startup by Windows.
.PP
Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated by all active channels on the device.
.PP
See \fBnvmlMemory_t\fP for details on available memory info.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImemory\fP Reference in which to return the memory information
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImemory\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImemory\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMinorNumber (nvmlDevice_t device, unsigned int * minorNumber)"
.PP
Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for each GPU will have the form /dev/nvidia[minor number].
.PP
For all products. Supported only for Linux
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIminorNumber\fP Reference in which to return the minor number for the device 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if the minor number is successfully retrieved
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIminorNumber\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if this query is not supported by the device
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetMultiGpuBoard (nvmlDevice_t device, unsigned int * multiGpuBool)"
.PP
Retrieves whether the device is on a Multi-GPU Board Devices that are on multi-GPU boards will set \fImultiGpuBool\fP to a non-zero value.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImultiGpuBool\fP Reference in which to return a zero or non-zero value to indicate whether the device is on a multi GPU board
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImultiGpuBool\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImultiGpuBool\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetName (nvmlDevice_t device, char * name, unsigned int length)"
.PP
Retrieves the name of this device.
.PP
For all products.
.PP
The name is an alphanumeric string that denotes a particular product, e.g. Tesla (TM) C2070. It will not exceed 64 characters in length (including the NULL terminator). See \fBnvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIname\fP Reference in which to return the product name 
.br
\fIlength\fP The maximum allowed length of the string returned in \fIname\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIname\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIname\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIlength\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetP2PStatus (nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuP2PCapsIndex_t p2pIndex, nvmlGpuP2PStatus_t * p2pStatus)"
.PP
Retrieve the status for a given p2p capability index between a given pair of GPU
.PP
\fBParameters:\fP
.RS 4
\fIdevice1\fP The first device 
.br
\fIdevice2\fP The second device 
.br
\fIp2pIndex\fP p2p Capability Index being looked for between \fIdevice1\fP and \fIdevice2\fP 
.br
\fIp2pStatus\fP Reference in which to return the status of the \fIp2pIndex\fP between \fIdevice1\fP and \fIdevice2\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIp2pStatus\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice1\fP or \fIdevice2\fP or \fIp2pIndex\fP is invalid or \fIp2pStatus\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPcieReplayCounter (nvmlDevice_t device, unsigned int * value)"
.PP
Retrieve the PCIe replay counter.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIvalue\fP Reference in which to return the counter's value
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIvalue\fP and \fIrollover\fP have been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIvalue\fP or \fIrollover\fP are NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPcieThroughput (nvmlDevice_t device, \fBnvmlPcieUtilCounter_t\fP counter, unsigned int * value)"
.PP
Retrieve PCIe utilization information. This function is querying a byte counter over a 20ms interval and thus is the PCIe throughput over that interval.
.PP
For Maxwell (TM) or newer fully supported devices.
.PP
This method is not supported on virtualized GPU environments.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcounter\fP The specific counter that should be queried \fBnvmlPcieUtilCounter_t\fP 
.br
\fIvalue\fP Reference in which to return throughput in KB/s
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIvalue\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP or \fIcounter\fP is invalid, or \fIvalue\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPciInfo (nvmlDevice_t device, \fBnvmlPciInfo_t\fP * pci)"
.PP
Retrieves the PCI attributes of this device.
.PP
For all products.
.PP
See \fBnvmlPciInfo_t\fP for details on the available PCI info.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIpci\fP Reference in which to return the PCI info
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpci\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIpci\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPerformanceState (nvmlDevice_t device, \fBnvmlPstates_t\fP * pState)"
.PP
Retrieves the current performance state for the device.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
See \fBnvmlPstates_t\fP for details on allowed performance states.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIpState\fP Reference in which to return the performance state reading
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpState\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIpState\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPersistenceMode (nvmlDevice_t device, \fBnvmlEnableState_t\fP * mode)"
.PP
Retrieves the persistence mode associated with this device.
.PP
For all products. For Linux only.
.PP
When driver persistence mode is enabled the driver software state is not torn down when the last client disconnects. By default this feature is disabled.
.PP
See \fBnvmlEnableState_t\fP for details on allowed modes.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImode\fP Reference in which to return the current driver persistence mode
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImode\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImode\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetPersistenceMode()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPowerManagementDefaultLimit (nvmlDevice_t device, unsigned int * defaultLimit)"
.PP
Retrieves default power management limit on this device, in milliwatts. Default power management limit is a power management limit that the device boots with.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIdefaultLimit\fP Reference in which to return the default power management limit in milliwatts
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdefaultLimit\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIdefaultLimit\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPowerManagementLimit (nvmlDevice_t device, unsigned int * limit)"
.PP
Retrieves the power management limit associated with this device.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
The power limit defines the upper boundary for the card's power draw. If the card's total power draw reaches this limit the power management algorithm kicks in.
.PP
This reading is only available if power management mode is supported. See \fBnvmlDeviceGetPowerManagementMode\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIlimit\fP Reference in which to return the power management limit in milliwatts
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIlimit\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIlimit\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPowerManagementLimitConstraints (nvmlDevice_t device, unsigned int * minLimit, unsigned int * maxLimit)"
.PP
Retrieves information about possible values of power management limits on this device.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIminLimit\fP Reference in which to return the minimum power management limit in milliwatts 
.br
\fImaxLimit\fP Reference in which to return the maximum power management limit in milliwatts
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIminLimit\fP and \fImaxLimit\fP have been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIminLimit\fP or \fImaxLimit\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetPowerManagementLimit\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPowerManagementMode (nvmlDevice_t device, \fBnvmlEnableState_t\fP * mode)"
.PP
This API has been deprecated.
.PP
Retrieves the power management mode associated with this device.
.PP
For products from the Fermi family.
.IP "\(bu" 2
Requires \fINVML_INFOROM_POWER\fP version 3.0 or higher.
.PP
.PP
For from the Kepler or newer families.
.IP "\(bu" 2
Does not require \fINVML_INFOROM_POWER\fP object.
.PP
.PP
This flag indicates whether any power management algorithm is currently active on the device. An enabled state does not necessarily mean the device is being actively throttled -- only that that the driver will do so if the appropriate conditions are met.
.PP
See \fBnvmlEnableState_t\fP for details on allowed modes.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImode\fP Reference in which to return the current power management mode
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fImode\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fImode\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPowerState (nvmlDevice_t device, \fBnvmlPstates_t\fP * pState)"
.PP
Deprecated: Use \fBnvmlDeviceGetPerformanceState\fP. This function exposes an incorrect generalization.
.PP
Retrieve the current performance state for the device.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
See \fBnvmlPstates_t\fP for details on allowed performance states.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIpState\fP Reference in which to return the performance state reading
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpState\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIpState\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetPowerUsage (nvmlDevice_t device, unsigned int * power)"
.PP
Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)
.PP
For Fermi (TM) or newer fully supported devices.
.PP
On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw.
.PP
It is only available if power management mode is supported. See \fBnvmlDeviceGetPowerManagementMode\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIpower\fP Reference in which to return the power usage information
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpower\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIpower\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support power readings
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetRetiredPages (nvmlDevice_t device, \fBnvmlPageRetirementCause_t\fP cause, unsigned int * pageCount, unsigned long long * addresses)"
.PP
Returns the list of retired pages by source, including pages that are pending retirement The address information provided from this API is the hardware address of the page that was retired. Note that this does not match the virtual address used in CUDA, but will match the address information in XID 63
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcause\fP Filter page addresses by cause of retirement 
.br
\fIpageCount\fP Reference in which to provide the \fIaddresses\fP buffer size, and to return the number of retired pages that match \fIcause\fP Set to 0 to query the size without allocating an \fIaddresses\fP buffer 
.br
\fIaddresses\fP Buffer to write the page addresses into
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpageCount\fP was populated and \fIaddresses\fP was filled
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIpageCount\fP indicates the buffer is not large enough to store all the matching page addresses. \fIpageCount\fP is set to the needed size.
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIpageCount\fP is NULL, \fIcause\fP is invalid, or \fIaddresses\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device doesn't support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetRetiredPagesPendingStatus (nvmlDevice_t device, \fBnvmlEnableState_t\fP * isPending)"
.PP
Check if any pages are pending retirement and need a reboot to fully retire.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIisPending\fP Reference in which to return the pending status
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIisPending\fP was populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIisPending\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device doesn't support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetSamples (nvmlDevice_t device, \fBnvmlSamplingType_t\fP type, unsigned long long lastSeenTimeStamp, \fBnvmlValueType_t\fP * sampleValType, unsigned int * sampleCount, \fBnvmlSample_t\fP * samples)"
.PP
Gets recent samples for the GPU.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by the driver.
.PP
Power, Utilization and Clock samples are returned as type 'unsigned int' for the union \fBnvmlValue_t\fP.
.PP
To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL. The returned samplesCount will provide the number of samples that can be queried. The user needs to allocate the buffer with size as samplesCount * sizeof(nvmlSample_t).
.PP
lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query to get more recent samples.
.PP
This method fetches the number of entries which can be accommodated in the provided samples array, and the reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier for the target device 
.br
\fItype\fP Type of sampling event 
.br
\fIlastSeenTimeStamp\fP Return only samples with timestamp greater than lastSeenTimeStamp. 
.br
\fIsampleValType\fP Output parameter to represent the type of sample value as described in nvmlSampleVal_t 
.br
\fIsampleCount\fP Reference to provide the number of elements which can be queried in samples array 
.br
\fIsamples\fP Reference in which samples are returned
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if samples are successfully retrieved
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIsamplesCount\fP is NULL or reference to \fIsampleCount\fP is 0 for non null \fIsamples\fP 
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if this query is not supported by the device
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_NOT_FOUND\fP if sample entries are not found
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetSerial (nvmlDevice_t device, char * serial, unsigned int length)"
.PP
Retrieves the globally unique board serial number associated with this device's board.
.PP
For all products with an inforom.
.PP
The serial number is an alphanumeric string that will not exceed 30 characters (including the NULL terminator). This number matches the serial number tag that is physically attached to the board. See \fBnvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIserial\fP Reference in which to return the board/module serial number 
.br
\fIlength\fP The maximum allowed length of the string returned in \fIserial\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIserial\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIserial\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIlength\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetSupportedClocksThrottleReasons (nvmlDevice_t device, unsigned long long * supportedClocksThrottleReasons)"
.PP
Retrieves bitmask of supported clocks throttle reasons that can be returned by \fBnvmlDeviceGetCurrentClocksThrottleReasons\fP
.PP
For all fully supported products.
.PP
This method is not supported on virtualized GPU environments.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIsupportedClocksThrottleReasons\fP Reference in which to return bitmask of supported clocks throttle reasons
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIsupportedClocksThrottleReasons\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIsupportedClocksThrottleReasons\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBNvmlClocksThrottleReasons\fP 
.PP
\fBnvmlDeviceGetCurrentClocksThrottleReasons\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetSupportedGraphicsClocks (nvmlDevice_t device, unsigned int memoryClockMHz, unsigned int * count, unsigned int * clocksMHz)"
.PP
Retrieves the list of possible graphics clocks that can be used as an argument for \fBnvmlDeviceSetApplicationsClocks\fP.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fImemoryClockMHz\fP Memory clock for which to return possible graphics clocks 
.br
\fIcount\fP Reference in which to provide the \fIclocksMHz\fP array size, and to return the number of elements 
.br
\fIclocksMHz\fP Reference in which to return the clocks in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcount\fP and \fIclocksMHz\fP have been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_NOT_FOUND\fP if the specified \fImemoryClockMHz\fP is not a supported frequency
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIclock\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIcount\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetApplicationsClocks\fP 
.PP
\fBnvmlDeviceGetSupportedMemoryClocks\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetSupportedMemoryClocks (nvmlDevice_t device, unsigned int * count, unsigned int * clocksMHz)"
.PP
Retrieves the list of possible memory clocks that can be used as an argument for \fBnvmlDeviceSetApplicationsClocks\fP.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIcount\fP Reference in which to provide the \fIclocksMHz\fP array size, and to return the number of elements 
.br
\fIclocksMHz\fP Reference in which to return the clock in MHz
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIcount\fP and \fIclocksMHz\fP have been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIcount\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIcount\fP is too small (\fIcount\fP is set to the number of required elements)
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceSetApplicationsClocks\fP 
.PP
\fBnvmlDeviceGetSupportedGraphicsClocks\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetTemperature (nvmlDevice_t device, \fBnvmlTemperatureSensors_t\fP sensorType, unsigned int * temp)"
.PP
Retrieves the current temperature readings for the device, in degrees C.
.PP
For all products.
.PP
See \fBnvmlTemperatureSensors_t\fP for details on available temperature sensors.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIsensorType\fP Flag that indicates which sensor reading to retrieve 
.br
\fItemp\fP Reference in which to return the temperature reading
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fItemp\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIsensorType\fP is invalid or \fItemp\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not have the specified sensor
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetTemperatureThreshold (nvmlDevice_t device, \fBnvmlTemperatureThresholds_t\fP thresholdType, unsigned int * temp)"
.PP
Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
See \fBnvmlTemperatureThresholds_t\fP for details on available temperature thresholds.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIthresholdType\fP The type of threshold value queried 
.br
\fItemp\fP Reference in which to return the temperature reading 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fItemp\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIthresholdType\fP is invalid or \fItemp\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not have a temperature sensor or is unsupported
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetTopologyCommonAncestor (nvmlDevice_t device1, nvmlDevice_t device2, \fBnvmlGpuTopologyLevel_t\fP * pathInfo)"
.PP
Retrieve the common ancestor for two devices For all products. Supported on Linux only.
.PP
\fBParameters:\fP
.RS 4
\fIdevice1\fP The identifier of the first device 
.br
\fIdevice2\fP The identifier of the second device 
.br
\fIpathInfo\fP A \fBnvmlGpuTopologyLevel_t\fP that gives the path type
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIpathInfo\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice1\fP, or \fIdevice2\fP is invalid, or \fIpathInfo\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device or OS does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP an error has occurred in underlying topology discovery 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetTopologyNearestGpus (nvmlDevice_t device, \fBnvmlGpuTopologyLevel_t\fP level, unsigned int * count, nvmlDevice_t * deviceArray)"
.PP
Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level For all products. Supported on Linux only.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the first device 
.br
\fIlevel\fP The \fBnvmlGpuTopologyLevel_t\fP level to search for other GPUs 
.br
\fIcount\fP When zero, is set to the number of matching GPUs such that \fIdeviceArray\fP can be malloc'd. When non-zero, \fIdeviceArray\fP will be filled with \fIcount\fP number of device handles. 
.br
\fIdeviceArray\fP An array of device handles for GPUs found at \fIlevel\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdeviceArray\fP or \fIcount\fP (if initially zero) has been set
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP, \fIlevel\fP, or \fIcount\fP is invalid, or \fIdeviceArray\fP is NULL with a non-zero \fIcount\fP 
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device or OS does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP an error has occurred in underlying topology discovery 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetTotalEccErrors (nvmlDevice_t device, \fBnvmlMemoryErrorType_t\fP errorType, \fBnvmlEccCounterType_t\fP counterType, unsigned long long * eccCounts)"
.PP
Retrieves the total ECC error counts for the device.
.PP
For Fermi (TM) or newer fully supported devices. Only applicable to devices with ECC. Requires \fINVML_INFOROM_ECC\fP version 1.0 or higher. Requires ECC Mode to be enabled.
.PP
The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of errors across the entire device.
.PP
See \fBnvmlMemoryErrorType_t\fP for a description of available error types.
.br
 See \fBnvmlEccCounterType_t\fP for a description of available counter types.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIerrorType\fP Flag that specifies the type of the errors. 
.br
\fIcounterType\fP Flag that specifies the counter-type of the errors. 
.br
\fIeccCounts\fP Reference in which to return the specified ECC errors
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIeccCounts\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP, \fIerrorType\fP or \fIcounterType\fP is invalid, or \fIeccCounts\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error
.PP
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceClearEccErrorCounts()\fP 
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetUtilizationRates (nvmlDevice_t device, \fBnvmlUtilization_t\fP * utilization)"
.PP
Retrieves the current utilization rates for the device's major subsystems.
.PP
For Fermi (TM) or newer fully supported devices.
.PP
See \fBnvmlUtilization_t\fP for details on available utilization rates.
.PP
\fBNote:\fP
.RS 4
During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings. This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIutilization\fP Reference in which to return the utilization information
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIutilization\fP has been populated
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid or \fIutilization\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetUUID (nvmlDevice_t device, char * uuid, unsigned int length)"
.PP
Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string, that augments the immutable, board serial identifier.
.PP
For all products.
.PP
The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products. It does NOT correspond to any identifier printed on the board. It will not exceed 80 characters in length (including the NULL terminator). See \fBnvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIuuid\fP Reference in which to return the GPU UUID 
.br
\fIlength\fP The maximum allowed length of the string returned in \fIuuid\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIuuid\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIuuid\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIlength\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetVbiosVersion (nvmlDevice_t device, char * version, unsigned int length)"
.PP
Get VBIOS version of the device.
.PP
For all products.
.PP
The VBIOS version may change from time to time. It will not exceed 32 characters in length (including the NULL terminator). See \fBnvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE\fP.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIversion\fP Reference to which to return the VBIOS version 
.br
\fIlength\fP The maximum allowed length of the string returned in \fIversion\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIversion\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, or \fIversion\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_INSUFFICIENT_SIZE\fP if \fIlength\fP is too small
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceGetViolationStatus (nvmlDevice_t device, \fBnvmlPerfPolicyType_t\fP perfPolicyType, \fBnvmlViolationTime_t\fP * violTime)"
.PP
Gets the duration of time during which the device was throttled (lower than requested clocks) due to power or thermal constraints.
.PP
The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The difference in violation times at two different reference times gives the indication of GPU throttling event.
.PP
Violation for thermal capping is not supported at this time.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIperfPolicyType\fP Represents Performance policy which can trigger GPU throttling 
.br
\fIviolTime\fP Reference to which violation time related information is returned
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if violation time is successfully retrieved
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid, \fIperfPolicyType\fP is invalid, or \fIviolTime\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if this query is not supported by the device
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceOnSameBoard (nvmlDevice_t device1, nvmlDevice_t device2, int * onSameBoard)"
.PP
Check if the GPU devices are on the same physical board.
.PP
For all fully supported products.
.PP
\fBParameters:\fP
.RS 4
\fIdevice1\fP The first GPU device 
.br
\fIdevice2\fP The second GPU device 
.br
\fIonSameBoard\fP Reference in which to return the status. Non-zero indicates that the GPUs are on the same board.
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIonSameBoard\fP has been set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdev1\fP or \fIdev2\fP are invalid or \fIonSameBoard\fP is NULL
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if this check is not supported by the device
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the either GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceResetApplicationsClocks (nvmlDevice_t device)"
.PP
Resets the application clock to the default value
.PP
This is the applications clock that will be used after system reboot or driver reload. Default value is constant, but the current value an be changed using \fBnvmlDeviceSetApplicationsClocks\fP.
.PP
On Pascal and newer hardware, if clocks were previously locked with \fBnvmlDeviceSetApplicationsClocks\fP, this call will unlock clocks. This returns clocks their default behavior ofautomatically boosting above base clocks as thermal limits allow.
.PP
\fBSee also:\fP
.RS 4
\fBnvmlDeviceGetApplicationsClock\fP 
.PP
\fBnvmlDeviceSetApplicationsClocks\fP
.RE
.PP
For Fermi (TM) or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if new settings were successfully set
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceSetAutoBoostedClocksEnabled (nvmlDevice_t device, \fBnvmlEnableState_t\fP enabled)"
.PP
Try to set the current state of Auto Boosted clocks on a device.
.PP
For Kepler (TM) or newer fully supported devices.
.PP
Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock rates are desired.
.PP
Non-root users may use this API by default but can be restricted by root from using this API by calling \fBnvmlDeviceSetAPIRestriction\fP with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS. Note: Persistence Mode is required to modify current Auto Boost settings, therefore, it must be enabled.
.PP
On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks. Use \fBnvmlDeviceSetApplicationsClocks\fP and \fBnvmlDeviceResetApplicationsClocks\fP to control Auto Boost behavior.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIenabled\fP What state to try to set Auto Boosted clocks of the target device to
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP If the Auto Boosted clocks were successfully set to the state specified by \fIenabled\fP 
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support Auto Boosted clocks
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceSetCpuAffinity (nvmlDevice_t device)"
.PP
Sets the ideal affinity for the calling thread and device using the guidelines given in \fBnvmlDeviceGetCpuAffinity()\fP. Note, this is a change as of version 8.0. Older versions set the affinity for a calling process and all children. Currently supports up to 64 processors.
.PP
For Kepler (TM) or newer fully supported devices. Supported on Linux only.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if the calling process has been successfully bound
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceSetDefaultAutoBoostedClocksEnabled (nvmlDevice_t device, \fBnvmlEnableState_t\fP enabled, unsigned int flags)"
.PP
Try to set the default state of Auto Boosted clocks on a device. This is the default state that Auto Boosted clocks will return to when no compute running processes (e.g. CUDA application which have an active context) are running
.PP
For Kepler (TM) or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices. Requires root/admin permissions.
.PP
Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock rates are desired.
.PP
On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks. Use \fBnvmlDeviceSetApplicationsClocks\fP and \fBnvmlDeviceResetApplicationsClocks\fP to control Auto Boost behavior.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device 
.br
\fIenabled\fP What state to try to set default Auto Boosted clocks of the target device to 
.br
\fIflags\fP Flags that change the default behavior. Currently Unused.
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP If the Auto Boosted clock's default state was successfully set to the state specified by \fIenabled\fP 
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_NO_PERMISSION\fP If the calling user does not have permission to change Auto Boosted clock's default state.
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIdevice\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support Auto Boosted clocks
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceValidateInforom (nvmlDevice_t device)"
.PP
Reads the infoROM from the flash and verifies the checksums.
.PP
For all products with an inforom.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP The identifier of the target device
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if infoROM is not corrupted
.IP "\(bu" 2
\fBNVML_ERROR_CORRUPTED_INFOROM\fP if the device's infoROM is corrupted
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_GPU_IS_LOST\fP if the target GPU has fallen off the bus or is otherwise inaccessible
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlSystemGetTopologyGpuSet (unsigned int cpuNumber, unsigned int * count, nvmlDevice_t * deviceArray)"
.PP
Retrieve the set of GPUs that have a CPU affinity with the given CPU number For all products. Supported on Linux only.
.PP
\fBParameters:\fP
.RS 4
\fIcpuNumber\fP The CPU number 
.br
\fIcount\fP When zero, is set to the number of matching GPUs such that \fIdeviceArray\fP can be malloc'd. When non-zero, \fIdeviceArray\fP will be filled with \fIcount\fP number of device handles. 
.br
\fIdeviceArray\fP An array of device handles for GPUs found with affinity to \fIcpuNumber\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if \fIdeviceArray\fP or \fIcount\fP (if initially zero) has been set
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIcpuNumber\fP, or \fIcount\fP is invalid, or \fIdeviceArray\fP is NULL with a non-zero \fIcount\fP 
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device or OS does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP an error has occurred in underlying topology discovery 
.PP
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for NVML from the source code.
