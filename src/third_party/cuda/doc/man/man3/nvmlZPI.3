.TH "Drain states" 3 "12 Jan 2017" "Version 1.1" "NVML" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Drain states \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceModifyDrainState\fP (\fBnvmlPciInfo_t\fP *pciInfo, \fBnvmlEnableState_t\fP newState)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceQueryDrainState\fP (\fBnvmlPciInfo_t\fP *pciInfo, \fBnvmlEnableState_t\fP *currentState)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceRemoveGpu\fP (\fBnvmlPciInfo_t\fP *pciInfo)"
.br
.ti -1c
.RI "\fBnvmlReturn_t\fP DECLDIR \fBnvmlDeviceDiscoverGpus\fP (\fBnvmlPciInfo_t\fP *pciInfo)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This chapter describes methods that NVML can perform against each device to control their drain state and recognition by NVML and NVIDIA kernel driver. These methods can be used with out-of-band tools to power on/off GPUs, enable robust reset scenarios, etc. 
.SH "Function Documentation"
.PP 
.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceDiscoverGpus (\fBnvmlPciInfo_t\fP * pciInfo)"
.PP
Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device. If all are zeroes then the entire PCI tree will be searched. Please note that for long-running NVML processes the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order.
.PP
In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds per GPU. Also, all device handles are no longer guaranteed to be valid post discovery.
.PP
Must be run as administrator. For Linux only.
.PP
For newer than Maxwell (TM) fully supported devices. Some Kepler devices supported.
.PP
\fBParameters:\fP
.RS 4
\fIpciInfo\fP The PCI tree to be searched. Only the domain, bus, and device fields are used in this call.
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if counters were successfully reset
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fIpciInfo\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the operating system does not support this feature
.IP "\(bu" 2
\fBNVML_ERROR_OPERATING_SYSTEM\fP if the operating system is denying this feature
.IP "\(bu" 2
\fBNVML_ERROR_NO_PERMISSION\fP if the calling process has insufficient permissions to perform operation
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceModifyDrainState (\fBnvmlPciInfo_t\fP * pciInfo, \fBnvmlEnableState_t\fP newState)"
.PP
Modify the drain state of a GPU. This method forces a GPU to no longer accept new incoming requests. Any new NVML process will no longer see this GPU. Persistence mode for this GPU must be turned off before this call is made. Must be called as administrator. For Linux only.
.PP
For newer than Maxwell (TM) fully supported devices. Some Kepler devices supported.
.PP
\fBParameters:\fP
.RS 4
\fIpciInfo\fP The PCI address of the GPU drain state to be modified 
.br
\fInewState\fP The drain state that should be entered, see \fBnvmlEnableState_t\fP
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if counters were successfully reset
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fInvmlIndex\fP or \fInewState\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device doesn't support this feature
.IP "\(bu" 2
\fBNVML_ERROR_NO_PERMISSION\fP if the calling process has insufficient permissions to perform operation
.IP "\(bu" 2
\fBNVML_ERROR_IN_USE\fP if the device has persistence mode turned on
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceQueryDrainState (\fBnvmlPciInfo_t\fP * pciInfo, \fBnvmlEnableState_t\fP * currentState)"
.PP
Query the drain state of a GPU. This method is used to check if a GPU is in a currently draining state. For Linux only.
.PP
For newer than Maxwell (TM) fully supported devices. Some Kepler devices supported.
.PP
\fBParameters:\fP
.RS 4
\fIpciInfo\fP The PCI address of the GPU drain state to be queried 
.br
\fIcurrentState\fP The current drain state for this GPU, see \fBnvmlEnableState_t\fP
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if counters were successfully reset
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fInvmlIndex\fP or \fIcurrentState\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device doesn't support this feature
.IP "\(bu" 2
\fBNVML_ERROR_UNKNOWN\fP on any unexpected error 
.PP
.RE
.PP

.SS "\fBnvmlReturn_t\fP DECLDIR nvmlDeviceRemoveGpu (\fBnvmlPciInfo_t\fP * pciInfo)"
.PP
This method will remove the specified GPU from the view of both NVML and the NVIDIA kernel driver as long as no other processes are attached. If other processes are attached, this call will return NVML_ERROR_IN_USE and the GPU will be returned to its original 'draining' state. Note: the only situation where a process can still be attached after \fBnvmlDeviceModifyDrainState()\fP is called to initiate the draining state is if that process was using, and is still using, a GPU before the call was made. Also note, persistence mode counts as an attachment to the GPU thus it must be disabled prior to this call.
.PP
For long-running NVML processes please note that this will change the enumeration of current GPUs. For example, if there are four GPUs present and GPU1 is removed, the new enumeration will be 0-2. Also, device handles after the removed GPU will not be valid and must be re-established. Must be run as administrator. For Linux only.
.PP
For newer than Maxwell (TM) fully supported devices. Some Kepler devices supported.
.PP
\fBParameters:\fP
.RS 4
\fIpciInfo\fP The PCI address of the GPU to be removed
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
\fBNVML_SUCCESS\fP if counters were successfully reset
.IP "\(bu" 2
\fBNVML_ERROR_UNINITIALIZED\fP if the library has not been successfully initialized
.IP "\(bu" 2
\fBNVML_ERROR_INVALID_ARGUMENT\fP if \fInvmlIndex\fP is invalid
.IP "\(bu" 2
\fBNVML_ERROR_NOT_SUPPORTED\fP if the device doesn't support this feature
.IP "\(bu" 2
\fBNVML_ERROR_IN_USE\fP if the device is still in use and cannot be removed 
.PP
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for NVML from the source code.
